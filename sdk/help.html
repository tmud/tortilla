<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8">
<meta http-equiv="content-language" content="ru">
<title>Tortilla мад клиент</title>
<style type="text/css">
body{ background-color: #202020; color: #ffffff; font-size: 16px; font-family: consolas, tahoma; }
h1 { font-size: 40px; color: RGB(210,121,32); align: center; }
h2 { font-size: 28px; color: #1e9da8; }
h3 { font-size: 18px; color: #1e9da8; margin-bottom: 4px; }
h4 { font-size: 18px; color: yellow; margin-bottom: 2px; }
.t { color: #20c020; display: inline; }
.m { color: #20c020; display: inline; }
.e { color: #2080c0; display: inline; }
.ee { color: #909090; border-width: 1px; border-style: solid; width: 100% }
.cmd { color: yellow; display: inline; }
.leftimg { float:left; margin: 7px 7px 7px 0; }
.rightimg  { float: right; margin: 7px 0 7px 7px; }
a.content { color: #20c020; }
hr { border: 1px dashed; color: #909090; }
</style>
</head>
<body link="#3366cc" alink="#ff0000" vlink="#3366cc">
<a name="top"></a>
<center><h1>Tortilla SDK<br></h1></center>
<h2>Содержание</h2>
<ul>
<li><a href="#description">Описание, состав SDK</a></li>
<li><a href="#modules">Модули</a></li>
<li><a href="#plugins">Плагины</a></li>
<li><a href="#devcpp">Разработка на С,С++</a></li>
<li><a href="#devlua">Разработка на Lua</a></li>
<li><a href="#pluginsapi">Функции взаимодействия клиента с плагином, API плагина</a></li>
<li><a href="#clientapi">Функции взаимодействия плагина с клиентом, API клиента</a></li>
<li><a href="#strings">Cтроки, ньюансы работы в Lua</a></li>
<li><a href="#triggers">Триггеры на Lua</a></li>
<li><a href="#decoda">Decoda</a></li>
</ul>

<h2>Введение</h2>
Tortilla - это клиент для игры в текстовые многопользовательские онлайновые игры MUD (multi users dangeons, dimension or domains games).<br>
Предварительно следует ознакомиться с самой программой на <a href="https://github.com/tmud/tortilla" target="_blank">Сайте программы</a>. Данная информация предназначена для разработчиков под данный клиент.<br><br>
Разработка с помощью SDK предполагает испльзование языков программирования: <div class="m">C</div>, <div class="m">C++</div>, <div class="m">Lua 5.2</div>.<br><br>
Если вы не знаете <div class="m">Lua</div>, то его можно быстро выучить, благодаря этой статье <a href="http://tylerneylon.com/a/learn-lua/" target="_blank">Lua за 15 минут</a>. В данной 
статье собраны все основные правила данного языка, без лишней информации. Этих знаний будет вполне достаточно, чтобы научиться писать плагины и модули для клиента. Если будет желание 
изучить язык <div class="m">Lua</div> получше, то очень советую книгу <div class="m">Programming in Lua, 3rd Edition, Roberto Ierusalimschy</div>.
Дополнительно много информации и статей по данному языку, не считая официальную документацию <a href="http://lua.org" target="_blank">http://lua.org</a>, можно найти в интернете. 
Следует обратить внимание, что в клиенте используется <div class="m">Lua 5.2</div>.

<a name="description"></a>
<h2>Описание, состав SDK</h2>
Данный пакет SDK с набором компонентов предназначен для разработки плагинов и модулей для мад-клиента Tortilla.<br>
Он состоит из:
<ul>
<li><div class="m">Справки</div></li>
<li><div class="m">Библиотек и заголовочных файлов для компиляции</div></li>
<li><div class="m">Проектов-шаблонов, готовых для реализации в них нужного функционала</div></li>
<li><div class="m">Среды разработки для языка Lua - Decoda</div></li>
</ul>
Библиотеки и заголовочные файлы, а также проекты-шаблоны используются для разработки на языке С++. Они расчитаны на использование в <div class="m">Visual Studio 2013</div>.<br>
Если вы будете создавать в плагинах интерфейсные окна, то тогда <div class="m">Express</div> версия <div class="m">Visual Studio</div> скорее всего 
не подойдет, придется использовать <div class="m">Visual Studio 2013 Professional</div> и выше.<br>
Вполне возможна разработка плагинов и модулей на <div class="m">Delphi</div> и других языках, но для этого необходимо провести нужную подготовительную работу - создать или найти необходимые файлы 
для разработки и компиляции для этих языков.<br><br>
Decoda - это среда разработки и отладки на <div class="m">Lua</div>. Она позволяет писать и отлаживать скрипты на <div class="m">Lua</div>, при этом Decoda взаимодействует с мад-клиентом 
в процессе отладки. см. описание <a href="#decoda">Decoda</a>.<br><br>
Модули и плагины можно разрабатывать как на <div class="m">C/C++</div>, так и на <div class="m">Lua</div>. Предполагается, что основным языком разработки 
будет <div class="m">Lua</div>, а <div class="m">C/C++</div> будет больше вспомогательным, на котором будут написаны модули.<br>
Все модули и плагины могут взаимодействовать между собой и с самим клиентом, так как они подключены к общему процессору (виртуальной машине) <div class="m">Lua</div>.<br><br>

Различие между модулями и плагинами только в требованиях. У модулей требований нет, кроме как правил написания их для <div class="m">Lua</div>, а для плагины должны реализовать 
определенный набор функций, см. <a href="#pluginsapi">API для плагинов</a>, чтобы с ними мог работать клиент.

<a name="modules"></a>
<h2>Модули</h2>
Модули - это завершенные программные блоки (библиотеки) для использования в клиенте любым другими модулями или плагинами.<br>
Разрабатывать модули можно на любом языке и в основном это не <div class="m">Lua</div>, так как сам Lua - это расширяемый язык и чтобы на нем чтото сделать, нужно реализовать все основные возможности 
на других языках, а с помощью Lua все собрать в одно целое. В основном модули будут написаны на <div class="m">C/C++</div>, так как это необходимо для расширения возможностей <div class="m">Lua</div> в самом клиенте.
<br><br>
Программно все модули полностью соответствуют требованиям API для библиотек для языка <div class="m">Lua</div>. Поэтому можно использовать готовые Lua-библиотеки 
на просторах интернета. А модули, написанные для клиента, можно использовать в других проектах. Следует обратить внимание, что в клиенте используется <div class="m">Lua 5.2</div>.<br><br>
Все модули располагаются в папке <div class="m">modules</div> клиента. Модули на языке <div class="m">Lua</div> (с расширением <div class="m">*.lua</div>) загружаются автоматически при запуске клиента.<br>
Для загрузки модулей на языке <div class="m">C++</div> и возможно других языках, в виде <div class="m">*.dll</div> файлов, нужно воспользоваться функцией <div class="m">require</div> в Lua-скрипте.<br><br>
Пример:
<div class="ee">[local] module = require "module"</div>
Загружаем модуль с именем module.dll в объект-таблицу module. Имя объекта-таблицы можно использовать и другое! Если будет использовано ключевое слово local, 
то модуль будет доступен только в рамках данного Lua - файла, что рекомендуется делать, так как тогда модуль не будет мешать другим модулям (если в них будут использоваться те же самые имена, без слова local, то возникнет конфликт).
Об этом написано в документации к языку.
<a name="plugins"></a>
<h2>Плагины</h2>
Плагины - это специально написанные для мад-клиента программы, которые расширяют и улучшают возможности самого клиента. Плагины можно разрабатывать на любом языке, но в данном SDK 
присутствует возможность написать их на <div class="m">С</div>, <div class="m">С++</div> и <div class="m">Lua</div>.<br><br>
Файлы плагинов располагаются в папке <div class="m">plugins</div> в каталоге клиента. 
Плагины загружаются только тогда, когда разрешит пользователь. Пользователь управляет загрузкой плагинов в клиенте через специально диалоговое окно настроек (см. программу).

<a name="devcpp"></a>
<h2>Разработка на С и С++</h2>
Для разработки модулей-библиотек и плагинов на языке С++ требуется любая среда разработки на данном языке, например <div class="m">Visual Studio</div>, <div class="m">gcc</div>, <div class="m">Borland</div>. Можно разрабатывать библиотеки и 
на других языках, например <div class="m">Delphi</div>, но для этого нужны файлы для компиляции <div class="m">Lua</div> для данной среды разработки. Их можно найти в интернете. Еще также можно использовать уже готовые <div class="m">Lua</div> библиотеки из интернета.<br><br>
В SDK находяться необходимые для компиляции модулей-библиотек файлы. Данные файлы расчитаны на использование <div class="m">Visual Studio 2013</div> (желательно <div class="m">Professional</div> и выше).<br>
Файлы находятся в папке <div class="m">api</div>. Список файлов:
<ul>
<li><div class="m">base.h</div> - заголовочный файл, который нужно включить с помощью #include, если разрабатывается библиотека-модуль.</li>
<li><div class="m">api.h</div> - заголовочный файл, который нужно включить с помощью #include, если разрабатывается плагин.</li>
<li><div class="m">lua.h lualib.h lauxlib.h</div> - заголовочные файлы из библиотеки lua. Это необходимые вспомогательные файлы, которые подключаются в base.h и api.h</li>
<li><div class="m">api.lib lua.lib</div> - файлы для компиляции(библиотеки). Это также необходимые вспомогательные файлы. Они подключаются в base.h и api.h и дополнительно их подключать не требуется.</li>
</ul>
Разница между <div class="m">base.h</div> и <div class="m">api.h</div> в том, что в первом файле подключается только <div class="m">Lua</div>, а во втором еще дополнительно 
добавлено большое количество функций, которые могут понадобиться для плагинов, так называемое <div class="m">API</div>. Модули по идее не должны использовать <div class="m">API</div> клиента, так как они независимые самостоятельные 
библиотеки, которые можно использовать и в других проектах. Однако использовать <div class="m">API</div> клиента в модулях не запрещено, просто тогда модуль не сможет работать отдельно от 
<div class="m">API</div> в других проектах.<br><br>
Включать в проект нужно либо <div class="m">base.h</div>, либо <div class="m">api.h</div>, но не оба одновременно. Другие файлы включать в проект не нужно.<br>
Библиотеки <div class="m">api.lib, lua.lib</div> расчитаны на статическую линковку Runtime библиотеки в проекте.<br>
Для написания и отладки понадобится и сам клиент, так как он и будет подключать плагин/модуль и работать с ним в процессе разработки.<br><br>
Для написания модуля следует ознакомиться с документацией на язык <div class="m">Lua</div>, однако вкратце связь С++ - Lua работает так:<br>
1. У Lua есть параметр типа <div class="m">lua_State</div>, который является указателем на состояние виртуальной машины и он передается во всех функциях.<br>
2. Передача параметров в функцию Lua, а также получение параметров из функции происходит через стек. Для работы со стеком есть набор функций (см. ниже).<br>
3. Каждая функция <div class="m">Lua</div> на языке <div class="m">С/C++</div> выглядит так:
<pre><div class="ee">int function_name(lua_State *L)
{   ...
    return x;
}
</div></pre>
В качестве параметра выступает указатель на состояние виртуальной машины.<br>
Для работы со стеком, чтобы получить параметры, есть следующие основные функции:<br>
<ul>
<li>int lua_gettop(L) - количество параметров в стеке</li>
<li>int lua_isstring(L, index), lua_isnumber(L, index), ... - проверка на тип значения в стеке по заданному индексу</li>
<li>const char* lua_tostring(L, index), int lua_tointeger(L, index), ... - получение значения из стека по индексу нужного типа</li>
<li>void lua_pushstring(L, const char*), void lua_pushinteger(L, int), ... - затолкнуть в стек параметры</li>
<li>void lua_pop(L, count) - извлечь из стека нужное количество параметров</li>
<li>void lua_settop(L, count) - установить количество параметров на стеке (остальные отбросить, если они были)</li>
<li>void lua_newtable(L) - создает новую таблицу</li>
<li>void lua_settable(L, index) - добавляет значение с вершины стека в таблицу в позиции index</li>
</ul>
В качестве возращаемого значения - количество параметров на вершине стека, которые являются результатом работы функции. То есть функция на вершину 
стека должна поместить результат и вернуть количество параметров в результате. Следует заметить, что можно возвращать из функции сразу несколько значений.<br><br>
Взаимодействие с модулем или плагином происходит через объекты и/или функции, которые регистрирует сам модуль в вирутальной машине <div class="m">Lua</div>. Это 
может либо набор отдельных глобальных функций (м.б. и только одна), либо глобальный объект-таблица или несколько объектов-таблиц.<br>
Модуль должен реализовать функцию:<br>
<pre><div class="ee">int luaopen_xxx(lua_State *L)
{ 
  lua_newtable(L);
  ...
  return 1;
}
</div></pre><br>
Где 'xxx' имя модуля. Именно эту функцию ищет <div class="m">Lua</div> в dll, чтобы загрузить модуль. И данная функция должна зарегистрировать все необходимые функции и объекты,
чтобы Lua могла работать с модулем.<br>
В SDK есть пример модуля на <div class="m">C++</div> (заготовка-шаблон), где продемонстрированы все основные аспекты написания такого модуля.<br><br>
Плагин должен реализовать точно такую же функцию, только с именем <div class="m">plugin_open</div>, чтобы клиент смог его подключить. Список функций которые должны реализовать плагин 
представлены в разделе <a href="#pluginsapi">API для плагинов</a>. В SDK также есть пример плагина на <div class="m">С++</div>, в котором представлены аспекты уже для плагинов.<br><br>
Следующий аспект, который нужно учесть - это кодировка текстовых строк в плагинах и модулях. Это <div class="m">UTF8 !</div> То есть Lua объекты типа string - это строка 
символов в кодировке UTF8. В <div class="m">API</div> есть вспомогательные функции для работы с кодировками, см. <a href="#api">функции API</a>.

<a name="devlua"></a>
<h2>Разработка на Lua</h2>
Разработка модулей или плагинов на языке <div class="m">Lua</div> очень проста. Для этого нужно написать код модуля в текстовом файле.<br>
Исходный код модуля будет выглядеть примерно так:<br>
<pre><div class="ee">local module = {}
module.var = 0
function module.f1()
...
return result
end

function module.f2()
...
end
return module
</div></pre><br>
Это объявление пустой таблицы - с именем модуля. Таблица в <div class="m">Lua</div> является основным элементом в языке и используется в том числе для модулей. Далее идут функции модуля 
и его переменные. И это все! Все что требуется, это написать реализацию модуля. (PS. Синтакис исходного кода модуля не обязательно должен быть похожим на пример. В языке <div class="m">Lua</div> 
довольно широкие вариации написания кода. Читайте документацию к языку.)<br><br>
Однако, чтобы на <div class="m">Lua</div> можно было что-то сделать, базовые возможности уже должны быть реализованы. Это делается за счет других модулей. Если имеющихся возможностей не будет хватать, 
то их придется предварительно реализовать на <div class="m">C/С++</div> или взять готовый модуль из интернета. Модуль использует другой модуль - это принцип, который заложен в данный клиент, и
его нужно использовать. Это дает возможность для быстрого развития самого клиента.<br><br>
Написание плагинов не сложнее, чем написание модулей. Код плагина будет выглядеть примерно так:<br>
<pre><div class="ee">local plugin = {}
plugin.var = 0
function plugin.name()
return "Фильтр чата"
end

function plugin.description()
return "Данный плагин позволяет..."
end

function plugin.version()
return "1.0"
end

function plugin.init()
...
end
return plugin
</div></pre>
Для плагинов есть дополнительно набор требований (см. <a href="#pluginsapi">API для плагинов</a>), а в остальном они полностью идентичны модулям.
<br><br>
<div class="t">Правила при написании модулей и плагинов на Lua:</div>
<ul>
<li>Текстовый файл с исходным кодом должен быть в кодировке <div class="m">UTF8</div>. В данном файле должен присутствовать маркер <div class="m">BOM</div> для файлов в UTF8.</li>
<li>Весь код должен быть в рамках объектов-таблиц и функций, которые являются частью этой таблицы:<br>
<pre><div class="ee">local module = {} -- объект-таблица модуля
module.var = 0 -- переменная модуля
function module.f1() -- функция модуля
end
return module        -- в файле плагина/модуля в конце файла нужно вернуть главную таблицу модуляю

a = 10 -- оператор вне функции, так писать крайне не рекомедуется
f(10,20) -- вызов другой функции (не рекомендуется)

local b = 20 -- правильное написание
local t = {...} -- правильное написание
</div></pre></li>
Писать код вне функций не рекомендуется, так как этот код запускается в момент загрузки файла с исходным кодом в Lua - процессор (виртуальную машину). 
Последовательность загрузки модулей в клиенте может быть абсолютно любой, поэтому нет никаких гарантий, что в момент выполнения такого кода, все необходимые модули уже будут загружены. 
Для переменных вне функций следует использовать ключевое слово local, чтобы их ограничить рамками файла (иначе они будут глобальными для всей Lua-машины и возникнет вероятность конфликта 
между модулями и плагинами). Тоже самое относится к вспомогательным таблицам модуля (используйте local).
<li>Название файла с исходным текстом модуля или плагина должно совпадать с названием самого модуля или плагина, чтобы не было путаницы в файлах.</li>
</ul>

<a name="pluginsapi"></a>
<h2>Функции взаимодействия клиента с плагином, API плагина</h2>
В данном разделе представлены все функции, которые должны/могут быть реализованы на стороне плагина. Данные функции вызывает клиент. Когда эти функции будут вызваны описаны в самих функциях.<br>

<h3>Приоритетные функции</h3>
В работе плагинов есть понятие <div class="m">приоритета</div> и <div class="m">приоритетные функции</div>. Данные функции вызываются в том порядке, в котором указаны плагины в клиенте (см. программу). 
Эти функции используются при обработке данных мада в плагине и данные поступают от одного плагина к другому по цепочке(по приоритету), которую указал игрок в настройках. Это нужно учитывать 
при подключении плагинов.
<br><br>
<h3>Обзязательные функции плагина</h3>
Эти функции обязательны для плагина (без них клиент не будет работать с плагином):
<hr>
<h4>string name()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить название плагина.
<hr>
<h4>string description()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить подробное описание плагина  (что он делает и для чего предназначен).
<hr>
<h4>string version()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить версию плагина.
<hr>
<h3>Используемые функции плагина</h3>
Эти функции можно использовать при необходимости. Функции будут вызываться, если они объявлены в плагине.
<a name="init"></a>
<h4>void init()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент загрузки плагина. Предназначена для того, чтобы плагин настроил все необходимое для своей работы (например добавил пункт меню, см. <a href="#clientapi">API клиента</a>).
<hr>
<a name="release"></a>
<h4>void release()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент выгрузки плагина из клиента и памяти компьютера. Предназначена для того, чтобы плагин сохранил все данные и освободил ресурсы. 
Пункты меню и кнопки панели управления удалять не нужно (удаляются автоматически клиентом).
<hr>
<a name="activated"></a>
<h4>void activated()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается когда окно клиента становиться активным, т.е. основным окном, с которым работает игрок. Чтобы узнать текущее состояние 
клиента, нужно использовать метод <div class="cmd">props.activated</div>. См. <a href="#props" class="cmd">props</a>.
<hr>
<a name="deactivated"></a>
<h4>void deactivated()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается когда окно клиента перестает быть активным, например сворачивается, т.е. игрок теперь работает с другой программой. 
Текущее состояние клиента можно узнать с помощью <div class="cmd">props.activated</div>.
<hr>
<a name="menucmd"></a>
<h4>void menucmd(int id)</h4>
<div class="m">Параметры: id - целочисленное число</div><br>
<div class="m">Результат: нет<br></div><br>
Клиент вызывает данную функцию, когда пользователь выбирает пункт меню или нажимает кнопку на панели управления, которые относятся к плагину.
В качестве id возвращается идентификатор, который использовался при создании пункта меню или кнопки.
<hr>
<a name="closewindow"></a>
<h4>void closewindow(int hwnd)</h4>
<div class="m">Параметры: hwnd - дескриптор окна</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент закрытия окна плагина (если плагин создает окна, по клику на крестике окна плагина). 
В качестве параметра возращается число - дескриптор окна плагина.
<br>См.также: <a href="#createwindow" class="cmd">createWindow</a>
<hr>
<a name="streamdata"></a>
<h4>string streamdata(string stream)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: stream - строка, входной поток байт</div><br>
<div class="m">Результат: строка - выходной поток байт<br></div><br>
Функция предназначена для работы с потоком байт, который идет от мад сервера. В метод попадают данные так, как они приходят от мад сервера без 
предварительной обработки. Единственное, что делает клиент - работает со сжатием mccp(если включено), обрабатывает IAC TELNET опции, преобразует данные из 
кодировки сервера в кодировку UTF8. После этого данные попадают в этот метод.<br><br>
Функция обязательно должна вернуть строку - выходной поток данных. Если плагину необходимо изменить этот поток байт, то он может это сделать и вернуть 
уже другие данные. Если изменять данные не нужно, то необходимо вернуть строку-параметр с исходным потоком.
<hr>
<a name="barcmd"></a>
<h4>table barcmd(table сmds)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmds - таблица Lua со списком всех команд</div><br>
<div class="m">Результат: таблица - список команд после обработки<br></div><br>
Функция предназначена для работы со всеми командами, которые вводит пользователь в командной строке клиента. Она вызывается сразу же после ввода команды, еще 
до какой-либо обработки со стороны клиента. Клиент передает в функцию таблицу Lua, в которой перечислены все команды из командной строки 
(клиент разбивает строку на отдельные команды, если введено сразу несколько). Функция может изменить список команд. Если функция не меняет что-то в этом 
списке, то она должна вернуть исходную таблицу.
<hr>
<a name="historycmd"></a>
<h4>bool historycmd(string сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - команда</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция предназначена для работы с историей команд клиента. Данная функция вызывается для каждой команды, которую вводит пользователь. 
В качестве результата она должна вернуть булевское значение, которое означает <div class="m">false</div> - не записывать команду в историю клиента, <div class="m">true</div> - 
команду нужно записать. Клиент прекращает дальнейший вызов данной функции у плагинов, если возращается <div class="m">false</div>. 
Сюда не попадают команды, при многострочной вставки из буфера обмена. Команда вызывается до команды <a href="#barcmd" class="cmd">#barcmd</a>).
<hr>
<a name="gamecmd"></a>
<h4>table gamecmd(table сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - таблица с игровой командой и параметрами</div><br>
<div class="m">Результат: table - игровая команда + параметры, nil - команду отбросить<br></div><br>
Функция предназначена для работы с игровыми командами игрока (которые будут отправлены на мад-сервер). Сюда попадают все игровые команды, которые вводятся игроком или как результат работы триггеров. 
Плагин может, при необходимости изменить команду, или даже ее отбросить. Функция должна вернуть исходную таблицу (или true), если плагин не изменяет команду, или новую версию команды (nil, false или string если отбросить). 
Если использовать string, то будет выведена данная строка в лог плагинов, эту возможность можно использовать для вывода ошибки. 
В функцию попадает только одна команда, уже после всех обработок клиентом и готовая к отправке на сервер. 
В таблице команда находится под индексом 1. С индекса 2 начинаются параметры. Если нужно узнать количество элементов в таблице, можно выполнить операцию #t или lua_len.<br>
Если нужно предварительно обрабатывать команды, которые вводит пользователь, см. <a href="#barcmd" class="cmd">#barcmd</a>

<hr>
<a name="syscmd"></a>
<h4>table syscmd(table сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - таблица со системной командой и параметрами</div><br>
<div class="m">Результат: table - системная команда + параметры, nil - команду отбросить<br></div><br>
Функция предназначена для работы с системными командами (команды клиента, которые начинаются с символа #). Сюда попадают все системные команды, которые вводятся игроком или как результат работы триггеров. 
Плагин может, при необходимости изменить команду, или даже ее отбросить. Функция должна вернуть исходную таблицу (или true), если плагин не изменяет команду, или новую версию команды (nil, false или string если отбросить). 
Если использовать string, то будет выведена данная строка в лог плагинов, эту возможность можно использовать для вывода ошибки. 
Команда попадает в метод без ведущего символа системной команды #. В функцию попадает только одна команда, уже после всех обработок клиентом и готовая к выполнению клиентом. 
В таблице команда находится под индексом 1. С индекса 2 начинаются параметры. Если нужно узнать количество элементов в таблице, можно выполнить операцию #t или lua_len.<br>
Если нужно предварительно обрабатывать команды, которые вводит пользователь, см. <a href="#barcmd" class="cmd">#barcmd</a>

<hr>
<a name="before"></a>
<h4>void before(int view, viewdata data)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: view - индекс окна, data - объект-массив, со строками</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для работы с данными, которые приходят от мад-сервера в виде массива строк (клиент уже сформировал набор строк). Метод вызывается ДО (before) вызова обработчиков 
триггиров, подсветок, замен и других элементов. Он может использоватся как фильтр (удалять или заменять строки, менять цвет) или работать без изменения строк. 
В качестве первого параметра - индекс окна, для которого предназначен массив строк ( 0 - это главное окно мад-клиента, 1 и больше - это output окна клиента). 
В качестве второго параметра выступает специальный объект-массив, с помощью которого можно работать с массивом строк. 
<div class="m">Важно!</div> В этом методе нужно аккуратно пользоваться функцией <a href="#log" class="cmd">log</a>, так как данная строка вновь попадет в эту функцию, при следующей итерации. 
Для избежания бесконечного цикла, клиент отключает функцию log в момент обработки строк, попавших из log в предыдущей итерации.
<br>См.также: <a href="#viewdata" class="cmd">viewdata</a>, <a href="#cppviewdata" class="cmd">viewdata в С++</a>.
<hr>
<a name="after"></a>
<h4>void after(int view, viewdata data)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: view - индекс окна, data - объект-массив, со строками</div><br>
<div class="m">Результат: нет<br></div><br>
Функция идентична команде <a href="#before" class="cmd">before</a>, только она работает ПОСЛЕ (after) обработчиков триггиров, подсветок, замен и др. элементов. После этого метода 
строки попадают в главное окно мада или output-окно. 
<div class="m">Важно!</div> В этом методе нужно аккуратно пользоваться функцией <a href="#log" class="cmd">log</a>, так как данная строка вновь попадет в эту функцию, при следующей итерации. 
Для избежания бесконечного цикла, клиент отключает функцию log в момент обработки строк, попавших из log в предыдущей итерации.
<br>См.также: <a href="#viewdata" class="cmd">viewdata</a>, <a href="#cppviewdata" class="cmd">viewdata в С++</a>.
<hr>
<a name="connect"></a>
<h4>void connect()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается, когда клиент устанавливает соединение с мадом.
<hr>
<a name="disconnect"></a>
<h4>void disconnect()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается, когда клиент теряет соединение с мадом.
<hr>
<a name="msdp"></a>
<h4>void msdp(table data)</h4>
<div class="m">Параметры: data - таблица с данными протокола MSDP.</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается клиентом, когда от сервера получены данные по протоколу MSDP. Данные передаются в виде таблицы Lua 
(в виде ключ-переменная + значение в виде строк). В качестве значений могут быть пустые строки и таблицы. Таблица используется 
в случае, если получены msdp-массив или msdp-таблица. Для msdp-массива используются цифровые индексы 1+, для msdp-таблицы строковые ключи 
со значениями. Сам стандарт протокола можно прочитать тут: <a href="http://tintin.sourceforge.net/msdp/" target="_blank">MSDP</a>.
<hr>
<a name="msdpon"></a>
<h4>void msdpon()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается клиентом, когда установлено соединение по протоколу MSDP. После вызова этого метода можно вызывать функции для 
работы с протоколом. Cм. <a href="#luamsdp" class="cmd">lua msdp</a>, <a href="#cppmsdp" class="cmd">luaT_Msdp</a>. Далее все данные будут поступать 
через функцию <a href="#msdp" class="cmd">msdp</a>.
<hr>
<a name="msdpoff"></a>
<h4>void msdpoff()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается клиентом, когда соединение по протоколу MSDP закрылось. Тут можно произвести сброс плагина.
См. <a href="#msdpon" class="cmd">msdpon</a>.
<hr>
<a name="propsblocked"></a>
<h4>void propsblocked()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция используется для оповещения плагинов, о том, что было открыто окно настроек. Используется для разрешения проблемы конфликта, если 
триггеры макросы и др. элементы могут быть изменены в плагине. Данное событие <b>запрещает</b> изменять триггеры до прихода события <a href="#propsupdated" class="cmd">propsupdated</a>.<br>
См. <a href="#props" class="cmd">isPropertiesOpen</a>.
<hr>
<a name="propsupdated"></a>
<h4>void propsupdated()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция используется для оповещения плагинов, о том, что окно настроек было закрыто. Используется для разрешения проблемы конфликта, если 
триггеры макросы и др. элементы могут быть изменены в плагине. Данное событие <b>снимает запрет</b> на изменение триггеров.
См. <a href="#propsblocked" class="cmd">propsblocked</a>, <a href="#props" class="cmd">isPropertiesOpen</a>.
<hr>
<a name="clientapi"></a>
<h2>Функции взаимодействия плагина с клиентом, API клиента</h2>
<div class="m">API клиента</div> делиться на 2 части:
<ul>
<li><a href="#cppapi">С++ API</a> - представлена в файле <div class="m">api.h</div>, который входит в состав SDK.</li>
<li><a href="#luaapi">Lua API</a> - интегрирована в виртуальную машину клиента и доступна как из C++, так и Lua.</li>
</ul>
<a name="cppapi"></a>
<h3>API клиента C++</h3>
Все необходимое API для разработки плагинов находится в <div class="m">api.h</div>, его можно открыть и посмотеть подробно. В этом разделе 
представлено описание содержимого данного файла. Другой файл <div class="m">base.h</div> подключает <div class="m">API Lua</div> 
и с этой частью можно познакомиться в документации к языку.
<hr>
<h4>bool luaT_check(lua_State *L, int n, ...);</h4>
<div class="m">Параметры: n - количество параметров, ... - параметры</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция проверяет состояние стека Lua машины на соответствие параметрам. Нужно указать количество параметров и их типы. Функция 
предназначена для выбора нужной ветки кода в зависимости от параметров в С++ обработчиках вызовов со стороны Lua.
<hr>
<h4>bool luaT_run(lua_State *L, const char* func, const char* op, ...);</h4>
<div class="m">Параметры: func - название функции для запуска, op - количество и число параметров, ... - параметры</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция запускает Lua-функцию с заданным именем. Следующий параметр определяет количество и число параметров (одна буква - один параметр):
<ul>
<li>d - целое число (int)</li>
<li>s - строка (wchar_t*)</li>
<li>u - беззнаковое целое число (unsigned int)</li>
<li>o - объект или таблица, данный символ может быть только в первой позиции, сам объект/таблицу нужно предварительно поместить в стек через luaT_pushobject. 
Вызов метода идет в ООП режиме, когда в качестве первого параметра передается сам объект (в Lua это вызов функции через двоеточие).</li>
<li>t - таблица, если данный символ в первой позиции, то вызов метода происходит из самой таблицы. Саму таблицу нужно предварительно поместить в стек.</li>
</ul>
Далее, после строки с типом и числом параметров, идут сами параметры.
<hr>
<h4>int luaT_error(lua_State *L, const wchar_t* error_message);</h4>
<div class="m">Параметры: error_message - сообщение об ошибке</div><br>
<div class="m">Результат: число - значение с числом параметров на стеке, предназначено для передачи в Lua<br></div><br>
Функция предназначена для завершения какой-либо другой функции, в случае ошибки. Сообщение об ошибке передается в клиент, где и отображается.<br>
Пример:
<pre><div class="ee">int f(lua_State *L)
{ ...
  if (error) 
    return luaT_error('Ошибка');
  ...
}
</div></pre>
<hr>
<h4>int luaT_push_args(lua_State *L, const char* function_name);</h4>
<div class="m">Параметры: function_name - имя функции</div><br>
<div class="m">Результат: cтрока на стеке Lua. Содержит информацию о файле, строке файле, имени функции и параметрах<br></div><br>
Функция предназначена получения информации о вызываемой функции с параметрами, для отображения в логах. Информация для логов, для исправления ошибок.
</div>
<h3>API клиента Lua</h3>
<hr>
<h4>void* luaT_toobject(lua_State* L, int index);</h4>
<div class="m">Параметры: index - позиция в стеке Lua</div><br>
<div class="m">Результат: указатель на объект<br></div><br>
Функция возвращает указатель на объект по заданному индексу в стеке. Если это не объект, то возвращается NULL.<br>
<hr>
<h4>void luaT_pushobject(lua_State* L, void *object, int type);</h4>
<div class="m">Параметры: object - указатель на объект, type - тип объекта</div><br>
<div class="m">Результат: нет<br></div><br>
Помещает в стек Lua объект (его указатель) заданного типа.
<hr>
<h4>bool luaT_isobject(lua_State* L, int type, int index);</h4>
<div class="m">Параметры: type - тип объекта, index - позиция в стеке</div><br>
<div class="m">Результат: true/false<br></div><br>
Проверяет, что на стеке Lua находится объект заданного типа.
<hr>
<h4>void luaT_showLuaStack(lua_State* L, const char* label);</h4>
<div class="m">Параметры: label - текстовая метка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для отладки плагинов. Она через метод Win32API OutputDebugString выводит содержимое стека Lua на момент вызова. 
Эта информация попадает в отладчик C++. Эту информацию можно увидеть и с помощью программы <a href="http://technet.microsoft.com/en-us/sysinternals/bb896647.aspx" target="_blank">DebugView</a>, 
при условии что отладчик не работает (он перехватывает OutputDebugString). Текстовая метка используется для идентификации нужного вызова метода.
<hr>
<h4>void luaT_showTableOnTop(lua_State* L, const char* label);</h4>
<div class="m">Параметры: label - текстовая метка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для отладки плагинов. Она через метод Win32API OutputDebugString выводит содержимое таблицы на вершине стека Lua на момент вызова. 
см. <div class="m">luaT_showLuaStack</div>.
<hr>
<a name="luatwindow"></a>
<h4>class luaT_window</h4>
Любой плагин, при необходимости может создавать для себя дополнительные окна. Данный класс предназначен для облегчения решения этой задачи. 
Класс является оберткой вокруг Lua объекта Окно. В Lua есть аналог - <a href="#window" class="cmd">window</a>. 
В дополнительное окно можно подключить свое окно (использовать как контейнер), а можно рисовать (только из Lua-скриптов) с помощью встроенных 
возможностей в клиент (см. <a href="#render" class="cmd">render</a>).
<br>
<pre>
<div class="cmd">bool create(lua_State *pL, const wchar_t* caption, int width, int height)</div> - создание окна-контейера, с заданными 
размерами и заголовком.
<div class="cmd">HWND hwnd()</div> - получение дескриптора окна.
<div class="cmd">HWND floathwnd()</div> - получение дескриптора самого базового окна с рамкой и заголовком.
<div class="cmd">void hide()</div> - скрыть окно.
<div class="cmd">void show()</div> - показать окно.
<div class="cmd">bool isVisible()</div> - проверка видимо окно или нет.
<div class="cmd">void dock(const wchar_t* side)</div> - заставляет окно пристыковаться к нужной стороне клиента. 
Возможные варианты: 'left', 'right', 'top', 'bottom'. Допускается перечисление нескольких вариантов через запятую.
<div class="cmd">void undock()</div> - окно открепляется от окна клиента.
<div class="cmd">void block(const wchar_t* side)</div> - блокировка возможности прикрепить окно к определенной стороне. 
Возможные варианты: 'left', 'right', 'top', 'bottom', 'float'. Вариант 'float' означает, что окно не может быть 
плавающим и всегда должно быть пристыкованным. Допускается перечисление нескольких вариантов через запятую.
<div class="cmd">void attach(HWND child)</div> - подключение своего окна внутрь дополнительного окна. Дополнительное окно выступает 
в качестве контейнера.
<div class="cmd">void setFixedSize(int width, int height)</div> - Установка и фиксация размер окна. Изменить размер такого окна 
с помощью мышки будет невозможно.
<div class="cmd">SIZE getSize()</div> - получение размера окна.
</pre>
См. также <a href="#luatpanel" class="cmd">luaT_panel</a>.
<hr>
<a name="luatpanel"></a>
<h4>class luaT_panel</h4>
Панели - это еще один вид окон, кроме дополнительных окон, которые может создавать плагин. Панели - это окна, которые имеют фиксированный размер 
и распологаются на одной из сторон клиента. Панели нельзя перемещать. В Lua есть аналог - <a href="#panel" class="cmd">panel</a>. Панель создается на 
всю высоту или ширину окна клиента (в зависимости от стороны расположения), но с заданной шириной или высотой соответственно.
В дополнительное окно можно подключить свое окно (использовать как контейнер), а можно рисовать (только из Lua-скриптов) с помощью встроенных 
возможностей в клиент (см. <a href="#render" class="cmd">render</a>).
<pre>
<div class="cmd">bool create(lua_State *pL, const wchar_t* side, int size)</div> - создание панели. Нужно указать сторону, где будет 
располагаться панель и ее размер в пикселях. Вариант значения <div class="cmd">side</div> - 'left', 'right', 'top', 'bottom'.
<div class="cmd">void attach(HWND child)</div> - подключение своего окна внутрь панели. Панель выступает в качестве контейнера.
<div class="cmd">HWND hwnd()</div> - получение дескриптора окна панели.</div>
</pre>
См. также <a href="#luatwindow" class="cmd">luaT_window</a>.
<hr>
<a name="cppviewdata"></a>
<h4>class luaT_ViewData</h4>
Класс предназначен для манипуляции со строками, которые плагин получает от клиента. Используется при работе с методами <a href="#before" class="cmd">before</a>,  
<a href="#after" class="cmd">after</a>, <a href="#updateView" class="cmd">updateView</a>. В Lua есть подобный интерфейс <a href="#viewdata" class="cmd">viewdata</a>
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, т.е рабочий диапозон индексов [1..n]. Решение связано с интеграцией с языком Lua.
<pre>
<div class="cmd">void init(lua_State *pL, void *viewdata)</div> - инициализация.
<div class="cmd">int  size()</div> - количество строк.
<div class="cmd">bool select(int index)</div> - выбор строки для дальнейшей работы.
<div class="cmd">int  getIndex()</div> - индекс текущей строки.
<div class="cmd">bool isFirst()</div> - первая строка является продолжением последней строки (завершение предыдущей строки).
<div class="cmd">bool isLast()</div> - последняя строка является завершенной, ее продолжения в следующей коллекции не будет.
<div class="cmd">bool isGameCmd()</div> - в строке присутствует игровая команда.
<div class="cmd">bool isSystem()</div> - это строка со служебной информацией  (логи клиента и плагинов, команды клиента).
<div class="cmd">bool isPrompt()</div> - это prompt строка.
<div class="cmd">bool isDropped()</div> - строка была отброшена в одном из триггеров и не будет отображена в клиенте.
<div class="cmd">void getPrompt(std::Wstring *str)</div> - возвращает prompt-строку (без возможных команд в строке).
<div class="cmd">void getText(std::wstring* str)</div> - полный текст строки (без учета расцветки).
<div class="cmd">int  getTextLen()</div> - длина всей строки в символах (без учета расцветки).
<div class="cmd">void getHash(std::wstring* str)</div> - хэш сумма строки. Используется для быстрого сравнения строк.
<div class="cmd">int  blocks()</div> - количество отдельных блоков в текущей строке.
<div class="cmd">bool get(int block, int param, unsigned int *value)</div> - значение параметра блока текущей строки. Допустимые значения параметра:
<div class="m">TEXTCOLOR</div>, <div class="m">BKGCOLOR</div>, <div class="m">UNDERLINE</div>, <div class="m">ITALIC</div>, <div class="m">BLINK</div>, <div class="m">REVERSE</div>, <div class="m">EXTTEXTCOLOR</div>, <div class="m">EXTBKGCOLOR</div>.
<div class="cmd">bool set(int block, int param, unsigned int value)</div> - устанавливает значение параметра блока текущей строки.
<div class="cmd">void getBlockText(int block, std::wstring* str)</div> - текст блока текущей строки.
<div class="cmd">bool setBlockText(int block, const wchar_t* text)</div> - задает новый текст блоку текущей строки.
<div class="cmd">bool copyBlock(int block, int dst_string, int dst_block)</div> - копирует заданный блок текущей строки в другую строку.
<div class="cmd">bool deleteBlock(int block)</div> - удаляет блок текущей строки.
<div class="cmd">bool deleteAllBlocks()</div> - удаляет все блоки, остается пустая строка.
<div class="cmd">bool createString()</div> - создает новую пустую строку. Строка добавляется между текущей строкой и следующей за ней.
<div class="cmd">bool createString(bool system, bool gamecmd)</div> - новая строка. Параметры задают соответствующие флаги новой строки.
<div class="cmd">bool deleteString()</div> - удаляет текущую строку.
<div class="cmd">void print(int view)</div> - печатает текущую строку в заданное output-окно с цветом.
<div class="cmd">bool find(Pcre* p[, int from])</div> - ищет строку по регулярному выражению. Если строка найдена, то она становиться текущей.
Можно указать с какой строки нужно начинать поиск.
<div class="cmd">bool getBlockPos(int abspos, int *res_block, int *res_pos)</div> - возвращает номер блока и позицию в блоке для текущей 
строки по номеру символа во всей строке (полная строка). Предназначена для работы совместно с функцией <div class="cmd">luaT_ViewData::getText</div>.
<div class="cmd">bool setNext(bool next)</div> - используется в механизме деления строк. Устанавливает/снимает флаг, что следующая строка часть текущей.
<div class="cmd">bool setPrev(bool prev)</div> - Предыдущая строка часть текущей (механизм деления строк).
<div class="cmd">bool isNext()</div> - проверка флага, что следующая строка часть текущей (механизм деления строк).
<div class="cmd">bool isPrev()</div> - проверка флага, что предыдущая строка часть текущей (механизм деления строк).
</pre>
<hr>
<a name="cppactobj"></a>
<h4>class luaT_ActiveObjects</h4>
Класс предназначен для манипуляции с объектам клиента. <a href="#luaactobj" class="cmd">Подобная возможность</a> в Lua.<br>
Поддеживаемые типы объектов:
<ul>
<li><div class="m">aliases</div> - макросы</li>
<li><div class="m">actions</div> - триггеры</li>
<li><div class="m">subs</div> - замены</li>
<li><div class="m">antisubs</div> - антизамены</li>
<li><div class="m">highlights</div> - подсветки</li>
<li><div class="m">hotkeys</div> - горячие клавиши</li>
<li><div class="m">gags</div> - фильтры</li>
<li><div class="m">vars</div> - переменные</li>
<li><div class="m">groups</div> - группы</li>
<li><div class="m">timers</div> - таймеры</li>
<li><div class="m">tabs</div> - подстановки</li>
</ul>
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, т.е рабочий диапозон индексов [1..n]. Решение связано с интеграцией с языком Lua.
<pre>
<div class="cmd">luaT_ActiveObjects(lua_State *pL, const char* type)</div> - инициализация (конструктор), возможные типы см. выше.
<div class="cmd">int  size()</div> - количество элементов.
<div class="cmd">bool select(int index)</div> - выбор нужного элемента по индексу.
<div class="cmd">bool add(const wchar_t* key, const wchar_t* value, const wchar_t* group)</div> - добавление нового элемента. Если элемент существует, 
то выходит с ошибкой.
<div class="cmd">bool replace(const wchar_t* key, const wchar_t* value, const wchar_t* group)</div> - заменяет текущий элемент. Если элемент не существует, 
то добавляет новый.
<div class="cmd">bool del()</div> - удаление текущего элемента.
<div class="cmd">int  getIndex()</div> - получение позиции текущего элемента.
<div class="cmd">bool setIndex(int index)</div> - переместить текущий элемент в нужную позицию.
<div class="cmd">bool get(int param, std::wstring* value)</div> - получить параметр текущего элемента. Возможные варианты параметра:
<div class="m">KEY</div>, <div class="m">VALUE</div>, <div class="m">GROUP</div>.
<div class="cmd">bool set(int param, const wchar_t* value)</div> - установка нужного параметра у текущего элемента.
<div class="cmd">bool update()</div> - применить все изменения. Только после вызова этого оператора все изменения вступят в силу.
</pre>
<hr>
<a name="cppprops"></a>
<h4>class luaT_Props</h4>
Класс предназначен для получения текущих настроек клиента. в Lua есть такой же набор методов в объекте <a href="#props" class="cmd">props</a>.<br>
Методы класса:
<pre>
<div class="cmd">COLORREF paletteColor(int index)</div> - цвет из палитры клиента. Возможные значения индекса от 0 до 255.
<div class="cmd">COLORREF backgroundColor()</div> - цвет фона всех окон клиента.
<div class="cmd">void cmdPrefix(std::wstring* str)</div> - получение префикса системной команды клиента.
<div class="cmd">void cmdSeparator(std::wstring* str)</div> - получение разделителя команд клиента.
<div class="cmd">void serverHost(std::wstring* str)</div> - адрес сервера, куда подключен клиент (пустая строка, если нет подключения).
<div class="cmd">void serverPort(std::wstring* str)</div> - адрес порта подключения (пустая строка, если нет подключения).
<div class="cmd">bool connected()</div> - признак, что клиент подключен к маду.
<div class="cmd">HFONT currentFont()</div> - хэндл текущего шрифта клиента.
<div class="cmd">bool activated()</div> - признак, что окно клиента активно и игрок работает с ним.
<div class="cmd">bool isPropertiesOpen()</div> - признак, что открыто окно настроек клиента, см. <a href="#propsblocked" class="cmd">propsblocked</a>.
<div class="cmd">int pluginsLogWindow()</div> - номер окна, куда выводятся логи плагинов. Если вывод логов отключен возвращается -1.
</pre>
<hr>
<a name="cppmsdp"></a>
<h4>class luaT_Msdp</h4>
Класс предназначен для работы с протоколом MSDP. Методы класса отправляют серверу управялющие команды протокола. Данные поступают через 
метод <a href="#msdp" class="cmd">msdp</a> плагина. Стандарт протокола можно прочитать тут: <a href="http://tintin.sourceforge.net/msdp/" target="_blank">MSDP</a>.
<pre>
<div class="cmd">void list(const std::wstring&amp; listname)</div> - получение списка переменных заданной категории(списка).
<div class="cmd">void send(const std::vector&lt;std::wstring&gt;&amp; vars)</div> - однократное получение текущих значений переменных.
<div class="cmd">void reset(const std::vector&lt;std::wstring&gt;&amp; vars)</div> - сброс переменных в исходное состояние.
<div class="cmd">void report(const std::vector&lt;std::wstring&gt;&amp; vars)</div> - подписка на оповещение об изменении переменных.
<div class="cmd">void unreport(const std::vector&lt;std::wstring&gt;&amp; vars)</div> - отписка от оповещения.
</pre>
См. также <a href="#luamsdp" class="cmd">msdp</a>.
<hr>
<h4>Преобразование кодировок</h4>
В <div class="m">API</div> клиента есть методы для переобразования текста между различными кодировками.<br>
Для преобразования существуют специальные классы-обертки:
<pre>
<div class="cmd">const wchar_t* TU2W(const utf8* string)</div> - конвертация строки из UTF8 в UTF16
<div class="cmd">const utf8* TW2U(const wchar_t* string)</div> - конвертация строки из UTF16 в UTF8
<div class="cmd">const wchar_t* TA2W(const char* string)</div> - конвертация строки из ANSI в UTF16
<div class="cmd">const char* TW2A(const wchar_t* string)</div> - конвертация строки из UTF16 в ANSI

Объекты TU2W, TW2U, TA2W и TW2A - выполнены в виде классов, которые рассчитаны на использование в стиле функции:
<div class="ee">...
u8string x( TW2U(L"строка") );
...
</div>
Необходимость класса - удаление временного буфера для строки-результата конвертации.
</pre>
<hr>
<h4>Работа с XML</h4>
В <div class="m">API</div> клиента есть возможность работать с <div class="m">XML</div>.<br>

<h4>class xml::node</h4>
Класс представляет собой обертку вокруг методов работы с вершиной <div class="m">XML</div> документа.
<pre>
<div class="cmd">node(const wchar_t* rootnode)</div> - создание нового документа с заданным именем корнего узла
<div class="cmd">node(xnode xml_node)</div> - подключение обертки к вершине
<div class="cmd">bool load(const wchar_t *filename)</div> - загрузка в вершину xml-файла
<div class="cmd">bool save(const wchar_t *filename)</div> - запись вершины в xml-файл
<div class="cmd">void deletenode()</div> - удалить вершину.
<div class="cmd">void getname(std::wstring *name)</div> - имя вершины.
<div class="cmd">bool get(const wchar_t* attribute, std::wstring* value)</div> - атрибут вершины.
<div class="cmd">bool get(const wchar_t* attribute, int* value)</div> - атрибут вершины в виде числа.
<div class="cmd">bool get(const wchar_t* attribute, std::wstring* value)</div> - атрибут вершины в виде строки UTF16.
<div class="cmd">void set(const wchar_t* attribute, const wchar_t* value)</div> - задать атрибут.
<div class="cmd">void set(const wchar_t* attribute, int value)</div> - задать атрибут в виде числа.
<div class="cmd">void set(const wchar_t* attribute, const std::wstring& value)</div> - задать атрибут в виде строки UTF16.
<div class="cmd">void gettext(std::wstring *text)</div> - текст вершины.
<div class="cmd">void settext(const wchar_t* text)</div> - задать текст вершины.
<div class="cmd">xml::node createsubnode(const wchar_t* name)</div> - создать дочернюю вершину.
<div class="cmd">int  size()</div> - количество атрибутов у вершины.
<div class="cmd">bool getattrname(int index, std::wstring* value)</div> - имя атрибута по индексу.
<div class="cmd">bool getattrvalue(int index, std::wstring* value)</div> - значение атрибута по индексу.
<div class="cmd">bool move(const wchar_t* path)</div> - переместить вершину в другую позицию по заданному пути.
<div class="cmd">bool create(const wchar_t* path)</div> - создать вершину по заданному пути.
</pre>
<h4>class xml::request</h4>
Класс позволяет делать выборку нужных вершин по выражению. Похоже на запрос к базе данных.
<pre>
<div class="cmd">request(xnode node, const wchar_t *request_string)</div> - выбрать нужные дочерние вершины у текущей вершины по выражению.
<div class="cmd">request(xml::node& node, const wchar_t *request_string)</div> - выбрать нужные дочерние вершины у текущей вершины по выражению.
<div class="cmd">int  size()</div> - количество вершин в выборке.
<div class="cmd">bool empty()</div> - проверка, что выборка пустая.
<div class="cmd">xml::node operator[](int node_index)</div> - получить вершину выборки по индексу.
</pre>
<hr>
<a name="pcrecpp"></a>
<h4>Работа с регулярными выражениями</h4>
В <div class="m">API</div> клиента есть методы работы с текстами посредством регулярных выражений. Используется <a href="http://www.pcre.ru/" target="_blank">PCRE</a> диалект.<br>
В Lua также есть поддержка Pcre (см. <a href="#pcre" class="cmd">pcre</a>).
<h4>class Pcre</h4>
В регулярных выражениях круглые скобки <div class="m">'()'</div> имеют особый смысл. Они используются для выделения интересующей части искомой строки.<br>
Методы <div class="cmd">first</div>, <div class="cmd">last</div>, <div class="cmd">size</div> используются для работы с такими скобками. См. документацию 
по PCRE.
<pre>
<div class="cmd">bool init(const wchar_t* _rgxp)</div> - инициализация регулярным выражением.
<div class="cmd">bool find(const wchar_t* string)</div> - поиск в строке по регулярному выражению.
<div class="cmd">bool findall(const wchar_t* string)</div> - поиск всех подстрок в строке по регулярному выражению.
<div class="cmd">int  size()</div> - количество найденных параметров в круглых скобках + 1 (совпадение по всему регулярному выражению). 
<div class="m">Замечание:</div> Если поиск производился методом <div class="cmd">find</div>, то по индексу <div class="m">0</div> будут получены границы совпадения 
всего регулярного выражения, а с индекса <div class="m">1</div> начнутся совпадения для круглых скобок <div class="m">'()'</div>. Если поиск производился 
методом <div class="cmd">findall</div>, то по индексу <div class="m">0</div> будут границы всех совпадений (начало первого совпадения и конец последнего), 
а с индекса <div class="m">1</div> начнутся отдельные совпадения подстрок.
<div class="cmd">int  first(int index)</div> - начальная позиция в строке (индекс символа) по индексу параметра, с которого начинается 
совпадение по регулярному выражению.
<div class="cmd">int  last(int index)</div> - конечная позиция в строке (индекс символа+1), на котором заканчивается совпадение 
по регулярному выражению.
<div class="cmd">void get(int index, std::wstring *str)</div> - получить строку, которая находится в границах по заданному индексу.
<div class="cmd">void getRegExp(std::wstring *str)</div> - возвращает регулярное выражение.
</pre>
<hr>
<a name="imagecpp"></a>
<h4>Работа с изображениями</h4>
В <div class="m">API</div> клиента есть возможность работы с изображениями. Это загрузка изображений и их отрисовка на экране клиента или 
окнах плагинов.<br> Поддерживаются <div class="m">png</div>, <div class="m">jpg</div>, <div class="m">bmp</div>, <div class="m">gif</div> и <div class="m">ico</div> форматы. 
См. также <a href="#image" class="cmd">image</a>, <a href="#render" class="cmd">render</a>.
<h4>class Image</h4>
<pre>
<div class="cmd">bool load(const wchar_t* file, int option)</div> - загрузка изображения из файла. Параметр option - размер иконки(для *.ico), номер кадра(для *.gif).
Изображения остальных форматов игнорируют данный параметр (рекомендуется указывать 0).
<div class="cmd">bool cut(const Image&amp; from, int x, int y, int w, int h)</div> - создание изображения путем вырезания части из другого изображения.
<div class="cmd">void unload()</div> - удаление(выгрузка из памяти) изображения.
<div class="cmd">int width()</div> - ширина изображения в пикселях.
<div class="cmd">int height()</div> - высота изображения в пикселях.
<div class="cmd">void render(HDC dc, int x, int y)</div> - рисование картинки на контексте, с заданными координатами.
<div class="cmd">void render(HDC dc, int x, int y, int w, int h)</div> - рисование картинки, с авторастяжкой на заданный прямоугольник.</pre>
<hr>
<a name="luaapi"></a>
<h3>API клиента Lua</h3>
В данно разделе представлен набор функций, которые встроены в виртуальную машину Lua клиента.<br>
Подключены следующие функции и модули из стандартных библиотек <div class="m">Lua</div>:
<ul>
<li>Все стандартные методы Lua, функции: <div class="m">assert</div>, <div class="m">type</div>, <div class="m">tonumber</div>, <div class="m">tostring</div> и другие (см. документацию к <div class="m">Lua</div>).</li>
<li>Методы по работе таблицами: <div class="m">table.sort</div>, <div class="m">table.insert</div>, <div class="m">table.remove</div>, <div class="m">table.concat</div>, и др.</li>
<li>Математические методы: <div class="m">math.floor</div>, <div class="m">math.ceil</div>, <div class="m">math.random</div>, <div class="m">math.min</div>, <div class="m">math.max</div> и др.</li>
</ul>
Также подключены и функции <div class="m">API</div>. Данные методы доступны и из <div class="m">С++</div> кода с помощью метода <div class="cmd">luaT_run</div>. Если 
понять механизм взаимосвязи C++ - Lua, то можно вызывать любые функции Lua из кода С++.
<hr>
<h4>void addCommand(string cmd)</h4>
<div class="m">Параметры: cmd - системная команда</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет в клиент новую системную команду (через '#'). Данная команда будет участвовать в автоподстановках.
Через метод <a href="#syscmd" class="cmd">syscmd</a> плагин может реализовать функционал команды. Данная функция расчитана на 
использовании в методе <a href="#init" class="cmd">init</a>. Системная команда автоматически удаляется, в момент выгрузки плагина.
<hr>
<a name="runCommand"></a>
<h4>void runCommand(string cmd)</h4>
<div class="m">Параметры: cmd - игровая или системная команда</div><br>
<div class="m">Результат: нет<br></div><br>
Функция выполняет команду (или набор команд), если бы ее ввел человек. Для получения символов перфикса системной команды и разделителя, используйте 
команды <div class="cmd">props.cmdPrefix</div> и <div class="cmd">props.cmdSeparator()</div>. См. <a href="#props" class="cmd">props</a>
<hr>
<h4>void setCommand(string cmd)</h4>
<div class="m">Параметры: cmd - игровая или системная команда</div><br>
<div class="m">Результат: нет<br></div><br>
Функция копирует команду (или набор команд) в командную строку клиента (старое содержимое командной строки пропадает). Запуск на выполнение не производится.<br>
См. <a href="#runCommand" class="cmd">runCommand</a>.
<hr>
<h4>void sendCommand(string window, string cmd [, ...])</h4>
<div class="m">Параметры: window - имя игрового профиля или nil, cmd - игровая или системная команда, набор команд.</div><br>
<div class="m">Результат: нет<br></div><br>
Функция пересылает команду (или набор команд) в другой экземпляр клиента Tortilla. В параметре window нужно указать имя игрового профиля нужного клиента (отображается в заголовке окна). 
Можно в качестве имени окна указать пустую строку или nil, тогда команда будет отправлена всем экземплярам клиента, включая текущий.
<hr>
<h4>void addMenu(string path, int id[, int pos][, int bmp])</h4>
<div class="m">Параметры: path - путь, id - идентификатор, pos - позиция (необязательный параметр), bmp - иконка пункта меню (необязательный параметр)</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет в меню клиента новый пункт меню. Параметр path определяет метоположение пункта меню. Последнее слова в пути - это название пунка меню. 
id - идентификатор, который будет передан в функцию <a href="#menucmd" class="cmd">menucmd</a>, pos - местоположение пункта меню относительно других, если 
позиция не задана, то пункт меню добавляется в конец основного меню, bmp - идентификатор иконки для пункта меню, он загружается из ресурсов dll-файла плагина. 
Пункт меню автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>.<br>
Пример:
<pre><div class="ee">function plugin.init()
...
addMenu('Справочник/База предметов', 100, 1)
...
end
</div></pre>
Пример создаст пункт меню: 'Справочник' в главном меню, 'База предметов' - пункт в этом меню, идентификатор пункта 100, пункт 'Справочник' - будет на 
первой позиции в главном меню.
<hr>
<h4>void addButton(int bmp, int id, string tooltip)</h4>
<div class="m">Параметры: bmp - идентификатор картинки, id - идентификатор команды, tooltip - подсказка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет кнопку на панель инструментов клиента. Картинка загружается из ресурсов плагина. 
id - идентификатор, который будет передан в функцию <a href="#menucmd" class="cmd">menucmd</a>, tooltip - всплывающая подсказка, при наведении стрелки 
мыши на кнопку. Кнопка автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>. 
Картинка должна быть в формате <div class="m">BMP</div>.
<br>
<div class="m">Замечание:</div> загрузка картинки для Lua плагина (из файла) пока не реализована.
<hr>
<h4>void addToolbar(string name [,int buttons_size])</h4>
<div class="m">Параметры: name - название, buttons_size - размер кнопок (необязательный параметр)</div><br>
<div class="m">Результат: нет<br></div><br>
Функция создает новую панель инструментов (тулбар) с заданным именем. Дополнительно можно указать размер картинок, которые будут использоваться 
в кнопках на данном тулбаре. После создания, все последующие вызовы метода <div class="cmd">addButton</div> будут добавлять кнопки на данный тулбар. 
Тулбар автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>. 
<hr>
<h4>void hideToolbar(string name)</h4>
<div class="m">Параметры: name - название</div><br>
<div class="m">Результат: нет<br></div><br>
Функция скрывает панель инструментов (тулбар) с заданным именем.
<hr>
<h4>void showToolbar(string name)</h4>
<div class="m">Параметры: name - название</div><br>
<div class="m">Результат: нет<br></div><br>
Функция включает отображение панели инструментов (тулбар) с заданным именем.
<hr>
<h4>void checkMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция переводит пункт меню или кнопки в состояние checked. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void uncheckMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция снимает с пункта меню или кнопки состояние checked. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void enableMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция переводит пункт меню или кнопку в состояние активно. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void disableMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция блокирует пункт меню или кнопку (состояние заблокировано). Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>string getPath(string file)</h4>
<div class="m">Параметры: file - относительный путь к файлу</div><br>
<div class="m">Результат: полный путь к файлу<br></div><br>
Функция расчитывает полный путь к файлу по его относительному пути.<br>
Функция использует текущее имя группы профилей (мир) и имя плагина, чтобы плагин мог работать с разными профилями.<br>
Это файл для сохранения настроек плагина для всех персонажей в текущем мире(сервере).
<hr>
<h4>string getProfilePath()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: полный путь к файлу<br></div><br>
Функция расчитывает полный путь к файлу по имени группы профилей(мир), имени текущего профиля(персонаж), а также имени плагина.<br>
Возвращает путь к файлу - это индивидуальный файл плагина для текущего персонажа в текущем мире(сервере).
</div></pre>
<hr>
<h4>string getResource(string file)</h4>
<div class="m">Параметры: file - относительный путь к файлу</div><br>
<div class="m">Результат: полный путь к файлу<br></div><br>
Функция расчитывает полный путь к файлу-ресурсу по его относительному пути.<br>
Этот вариант функции предназначен для плагинов, у которых есть общие файлы для всех мадов. Функция использует имя плагина, 
но не использует имя мада, т.е. это предназначено для общих файлов, для всех мадов. Все ресурсы лежат в папке resources.
<hr>
<h4>string getProfile()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: имя текущего профиля (персонажа)<br></div><br>
Функция возвращает имя текущего профиля (персонажа).<br>
</div></pre>
<hr>
<h4>HWND getParent()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: хэндл окна клиента<br></div><br>
Функция возвращает идентификатор - хэндл окна мад клиента в Windows. Используется для работы с окнами в плагинах с интерфейсом.
<hr>
<h4>void flashWindow()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция заставляет мигать окно клиента в панели задач, для привлечения к себе внимания. Может использоваться для сигнализации 
о событиях, когда клиент не является текущим окном. 
<hr>
<h4>void saveTable(table t, string file)</h4>
<div class="m">Параметры: t - таблица для сохранения, file - имя файла</div><br>
<div class="m">Результат: нет<br></div><br>
Функция сохраняет заданную таблицу в файл. Данные сохраняются в виде xml. Поддерживаются только числа и строки, в качестве параметров таблицы. 
Допускается вложенность таблиц. Путь к файлу вычисляется, в зависимости от имени группы профилей (мир) и имени плагина. 
Функция предназначена для сохранения настроек плагина для каждого мира и персонажа в отдельности.
Пример сохранения настроек (таблица Lua) в файле, с учетом имени профиля(персонажа):
<pre><div class="ee">saveTable( {...}, getProfile()..".xml")</pre>
Клиент создаст файл по заданному пути: <div class="cmd">gamedata/имя группы профилей(мир)/имя плагина/имя профиля(персонажа).xml</div> 
и сохранит в него данные из таблицы. Неподдерживаемые типы параметров пропускаются.<br>
Функция поддерживает как xml формат, так и lua формат. Он определяется расширением файла. Если в расширении есть строка xml - то это xml, 
иначе это lua формат.
<hr>
<h4>table loadTable(string file)</h4>
<div class="m">Параметры: file - имя файла</div><br>
<div class="m">Результат: table - таблица<br></div><br>
Функция загружает таблицу из файла. Поддерживаются только числа и строки. Путь к файлу вычисляется, в зависимости от имени 
группы профилей (мир) и имени плагина (аналогично <div class="cmd">saveTable</div>). Функция предназначена для загрузки настроек плагина с 
учетом группы профилей, имени плагина и имени персонажа(при необходимости).
Пример загрузки настроек (таблица Lua) из файла, с учетом имени профиля(персонажа):
<pre><div class="ee">local t = loadTable(getProfile()..".xml")</pre>
Функция поддерживает как xml формат, так и lua формат. Он определяется расширением файла. Если в расширении есть строка xml - то это xml, 
иначе это lua формат.
<hr>
<a name="createwindow"></a>
<h4>window createWindow(string title [,int width, int height] [,bool visible])</h4>
<div class="m">Параметры: title - заголовок окна, width,height - ширина и высота окна, visible - видимость окна</div><br>
<div class="m">Результат: объект окно (window)<br></div><br>
Функция создает дополнительное окно (для отображения любой информации) - <a href="#window" class="cmd">window</a>. В качестве 
параметров - заголовок окна и размеры окна (ширина и высота). Плюс дополнительный параметр - видимость окна после его создания. 
Если параметр visible не задан, то окно загружает свое последнее состояние после закрытия программы.
<hr>
<a name="createpanel"></a>
<h4>panel createPanel(string side, int size)</h4>
<div class="m">Параметры: side - сторона, где нужно создать панель. size - размер панели в пикселях.</div><br>
<div class="m">Результат: объект панель (panel)<br></div><br>
Функция создает панель (для отображения любой информации) - <a href="#panel" class="cmd">panel</a>. В качестве 
параметров - сторона (возможные варианты: 'left', 'right', 'top', 'bottom') и размер в пикселях.
<hr>
<a name="createpcre"></a>
<h4>pcre createPcre(string regexp)</h4>
<div class="m">Параметры: string - строка с регулярным выражением.</div><br>
<div class="m">Результат: объект регулярки (pcre)<br></div><br>
Создает регулярное выражение <a href="#pcre" class="cmd">pcre</a> по строке. Возвращает <div class="m">nil</div>, если указана некорректная строка.
<hr>
<a name="updateview"></a>
<h4>void updateView(int view, function f)</h4>
<div class="m">Параметры: view - номер окна, которое нужно обработать. f - функция обработчик.</div><br>
<div class="m">Результат: нет<br></div><br>
Данная функция предназначена для чтения/изменения строк мад окон клиента. view = 0 - главное окна клиента, 1-6 - output окна. 
В данную функцию нужно передать функцию обработчик, куда будет передан объект <a href="#viewdata" class="cmd">viewdata</a> нужного окна. 
Прототип функции : <div class="m">void handler(viewdata)</div>.<br>
<div class="cmd">Внимание!</div> Данная функция ресурсоемкая и зависит от количества имеющихся строк в нужном окне клиента, т.е. может работать с 
заметными задержками.
<hr>
<a name="isViewVisible"></a>
<h4>bool isViewVisible(int view)</h4>
<div class="m">Параметры: view - номер окна.</div><br>
<div class="m">Результат: bool - статус видимости окна<br></div><br>
Возвращает статус окна - видимо/не видимо. Работает только с output-окнами(значения 1-6).
<hr>
<a name="showView"></a>
<h4>void showView(int view)</h4>
<div class="m">Параметры: view - номер окна.</div><br>
<div class="m">Результат: нет<br></div><br>
Включает отображение output-окна, если оно было скрыто. Работает только с output-окнами(значения 1-6).
<hr>
<a name="hideView"></a>
<h4>void hideView(int view)</h4>
<div class="m">Параметры: view - номер окна.</div><br>
<div class="m">Результат: нет<br></div><br>
Скрывает output-окно, если оно отображалось. Работает только с output-окнами(значения 1-6).
<hr>
<a name="getViewSize"></a>
<h4>int,int getViewSize(int view)</h4>
<div class="m">Параметры: view - номер окна.</div><br>
<div class="m">Результат: ширина и высота<br></div><br>
Функция рассчитывает ширину и высоту заданного окна в символах. Высота рассчитывается точно, ширина приблизительно (из-за разной ширины шрифта).
<hr>
<a name="log"></a>
<h4>void log(string message [,string messsage2, ...])</h4>
<div class="m">Параметры: message, message2 и т.д. - текст сообщения</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для вывода строки с логами в окно клиента. Окно для вывода строки указывается в общих настройках клиента. Это отдельный канал вывода 
текстовой информации из плагинов и предназначен для целей их отладки. Это канал для системных сообщений плагинов.
Функция поддерживает любое количество параметров (в этом случае они соединяются в одну общую строку). 
Поддерживаются числа, строки, булевые выражения.
<hr>
<a name="print"></a>
<h4>void print(string message [,string messsage2, ...])</h4>
<div class="m">Параметры: message, message2 и т.д. - текст сообщения</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для вывода строки в главное окно клиента. Это аналог команды клиента <div class="cmd">#output</div>. 
Поддерживается возможность задать цвет текста (см. описание к команде). Функция предназначена для вывода игровой информации в клиент. 
Она поддерживает любое количество параметров (в этом случае они соединяются в одну общую строку). Поддерживаются числа, строки, булевые выражения.
<hr>
<a name="vprint"></a>
<h4>void vprint(int view, string message [,string messsage2, ...])</h4>
<div class="m">Параметры: view - номер окна, message, message2 и т.д. - текст сообщения</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для вывода строки в окно клиента (не только главное). Это аналог команды клиента <div class="cmd">#woutput</div>. 
Функция является полным аналогом команды  <div class="cmd">print</div>, только дает возможность указать окно клиента, куда нужно выводить строку. 
<hr>
<h4>void terminate([string message [,string messsage2, ...]])</h4>
<div class="m">Параметры: message и т.д. - текст сообщения. Необязательный параметр.</div><br>
<div class="m">Результат: нет<br></div><br>
Функция выводит строки логов в окно клиента и выключает плагин. Используется для выключения плагином самого себя, в случае, 
если он не может продолжать работу по какой-либо причине. Текст ошибки передается, как параметр.
Функция поддерживает любое количество параметров (в этом случае они соединяются в одну общую строку). 
Поддерживаются числа, строки, булевые выражения. Окно для вывода указывается в настройках клиента.
<hr>
<h4>void pluginName(string name)</h4>
<div class="m">Параметры: name - имя плагина для следующего вызова.</div><br>
<div class="m">Результат: нет<br></div><br>
Функция используется для вызова методов api клиента из плагинов. Она должна использоваться только из внутренних методов клиента 
(это все методы плагина, короме тех, которых вызывает клиент - init, release и т.д.). Нужно указать имя плагина(модуля) в качестве параметра, 
чтобы клиент знал от чьего имени идет вызов. Действует на один последующий вызов. Признаком того, что не указан плагин при вызове - строчка
<div class="m">?плагин?</div> в логах о работе плагинов.
<hr>
<h4>bool regUnloadFunction(function f)</h4>
<div class="m">Параметры: f - функция Lua.</div><br>
<div class="m">Результат: bool<br></div><br>
Функция используется в механизме выгрузки модулей. С ее помощью можно зарегистрировать функцию, которая будет вызвана клиентом при его закрытии. 
Данная возможность предназначена для некоторых модулей, предъявляющих особые требования в своей работе и должна использоваться только в Lua-скриптах 
загрузки модулей. Возвращает true, если функция успешно зарегистрирована.
<hr>
<h4>СOLORREF,COLORREF translateColors(string s, COLORREF text, COLORREF bgnd)</h4>
<div class="m">Параметры: s - строка, text,bgnd - начальные значения цвета для текста и фона.</div><br>
<div class="m">Результат: COLORREF*2<br></div><br>
Функция транслирует текстовую строку в цвет текста (первое значение) и цвет фона. Строка должна быть в формате <a href="#color" class="cmd">colors</a>.
Если преобразование не удалось, возвращается nil. Начальные значения цветов используются, если текст или фон не были заданы в текстовой строке.
<hr>
<a name="createTrigger"></a>
<h4>trigger createTrigger(string trigger_string|table trigger_strings, function f)</h4>
<div class="m">Параметры: trigger_string или trigger_strings - текстовая строка или таблица строк триггера. f - функция обработчик.</div><br>
<div class="m">Результат: trigger - объект триггера, с помощью которого можно им управлять.<br></div><br>
Функция создает Lua-триггер. Можно создавать как однострочные, так и многострочные триггеры. Для многострочных триггеров все нужные строки задаются 
в виде таблицы строк. Необходимо указать функцию, которая будет вызвана, при срабатывании триггера. В данную функцию будет передан объект 
<a href="#viewdata" class="cmd">viewdata</a> с набором всех строк мада, на которых произошло срабатывание.<br>
Пример:
<div class="ee">
<pre>
local function in_trigger1(v)
-- v - это объект viewdata со строками мада
...
end

local function in_trigger2(v)
...
end

-- вызывается при загрузке плагина
function plugin.init()
  createTrigger("%1 приш%2 с %3", in_trigger1 )
  createTrigger( {"%1 оглушил %2.", "%1 упал%2 на пол."}, in_trigger2 )
end
</pre>
</div><br>
Тут создаются 2 триггера. Один - однострочный, другой - многострочный. При срабатывании триггера будет вызвана функция, указаная втрорым параметром. 
В функцию будет передан <a href="#viewdata" class="cmd">viewdata</a> со строками. Через этот объект можно делать изменения в тексте, цвете текста, а также получить параметры 
%1,%2 и т.д. из нужной строки триггера.
Подробнее про триггеры <a href="#triggers">тут</a>.
<hr>
<a name="window"></a>
<h4>window</h4>
Дополнительное окно создается с помощью функции <a href="#createwindow" class="cmd">createWindow</a>. Lua объект <div class="cmd">window</div> является тем же интерфейсом, 
что и <a href="#luatwindow" class="cmd">luaT_window</a> на стороне С++. Дополнительные окна - плавающие окна, с возможностью пристыковаться 
к границе главного окна клиента.
<pre>
<div class="cmd">void dock(string side)</div> - заставляет окно пристыковаться к нужной стороне клиента. 
Возможные варианты: 'left', 'right', 'top', 'bottom'. Допускается перечисление нескольких вариантов через запятую.
<div class="cmd">void undock()</div> - окно открепляется от окна клиента.
<div class="cmd">void block(string side)</div> - блокировка возможности прикрепить окно к определенной стороне.
Возможные варианты: 'left', 'right', 'top', 'bottom', 'float'. Вариант 'float' означает, что окно не может быть 
плавающим и всегда должно быть пристыкованным. Допускается перечисление нескольких вариантов через запятую.
<div class="cmd">void show()</div> - отображает окно.
<div class="cmd">void hide()</div> - скрывает окно.
<div class="cmd">bool isVisible()</div> - возвращает статус видимо окно или нет.
<div class="cmd">render setRender(function f)</div> - возвращает объект, с помощью которого можно будет рисовать. Не работает, если окно используется 
как контейнер. В качестве параметра выступает функция, которая будет вызываться клиентом в момент перерисовки окна. 
В ней следует использовать объект render, который был получен в данной функции. см. <a href="#render" class="cmd">render</a>.
<div class="cmd">void setFixedSize(int width, int height)</div> - Установка и фиксация размер окна. Изменить размер такого окна 
с помощью мышки будет невозможно.
<div class="cmd">int, int getSize()</div> - получение размера окна (ширина и высота).
</pre>
<hr>
<a name="panel"></a>
<h4>panel</h4>
Панели - окна, именющие фиксированный размер, располагаются на одной из сторон клиента, без возможности перемещения. см. <a href="#luatpanel" class="cmd">luaT_panel</a>. 
Панели в Lua создаются с помощью функции  <a href="#createpanel" class="cmd">createPanel</a>. 
<pre><!-- <div class="cmd">void attach(HWND child)</div> - подключение своего окна в панель-контейнер. -->
<div class="cmd">render setRender(function f)</div> - возвращает объект, с помощью которого можно будет рисовать. Не работает, если окно используется 
как контейнер. В качестве параметра выступает функция, которая будет вызываться клиентом в момент перерисовки окна. 
В ней следует использовать объект render, который был получен в данной функции. см. <a href="#render" class="cmd">render</a>.
</pre>
<hr>
<a name="render"></a>
<h4>render</h4>
В дополнительных окнах и панелях клиента можно рисовать с помощью встроенных возможностей в клиент. Рисовать можно только с 
помощью Lua-скриптов, так как для C++ варианта доступно все окно и тут можно делать любые действия, а в Lua возможности 
ограничены клиентом. Данная возможность сделана для быстрой разработки на Lua плагинов-виджетов, необходимых для игры.<br><br>
<div class="m">Важно!</div> Не вызвайте напрямую функцию рисования (которая была установлена через 
<div class="cmd">window:setRender</div> или <div class="cmd">panel:setRender</div>). Если необходимо перерисовать окно, то 
нужно использовать <div class="cmd">render:update()</div>.
<pre>
<div class="cmd">void setBackground(color)</div> - Установка цвета фона окна.<br>
<a name="color"></a>
Возможные варианты определения цвета <div class="m">color</div>:
<ul>- r, g, b - цвет через три числа - компонеты отдельного цвета.
- color - цвет через одно общее число
- { r=10,g=20,b=30 } - цвет как таблица с указанием значений отдельных компонентов цвета.
</ul>Примеры:<div class="ee">render:setBackground(10, 20, 30)
render:setBackground(10203)
render:setBackground{ r=10,g=20,b=30 }
</div>

<div class="cmd">void textColor(color)</div> - цвет текста (см. <a class="cmd" href="#color">color</a>).
<div class="cmd">int width()</div> - ширина окна.
<div class="cmd">int height()</div> - высота окна.

<div class="cmd">pen createPen(table params)</div> - создание пера.
Параметры для создания пера <div class="m">pen</div>:
<ul>- <div class="m">style</div> - стиль пера. Возможные варианты: <div class="m">solid</div> (по умолчанию), <div class="m">dash</div>, <div class="m">dot</div>.
- <div class="m">width</div> - ширина пера (от 1 до 10 пикселей).
- <div class="m">color</div> - цвет пера (см. <a class="cmd" href="#color">color</a>).
</ul><div class="cmd">brush createBrush(table params)</div> - создание кисти.
Параметры для создания кисти <div class="m">brush</div>:
<ul>- <div class="m">style</div> - стиль кисти. Возможные варианты: <div class="m">solid</div> (по умолчанию), <div class="m">vertical</div>, <div class="m">horizontal</div>, 
<div class="m">cross</div>, <div class="m">diagonal</div>, <div class="m">diagcross</div>.
- <div class="m">color</div> - цвет кисти (см. <a class="cmd" href="#color">color</a>).
</ul>
<div class="cmd">font createFont(table params)</div> - создание шрифта.
Параметры для создания шрифта <div class="m">font</div>:
<ul>- <div class="m">name</div> - имя шрифта. Например: arial, tahoma, fixedsys.
- <div class="m">height</div> - высота шрифта.
- <div class="m">bold</div> - толщина шрифта.
- <div class="m">italic</div> - признак курсива шрифта.
</ul>
Пример:<div class="ee">local font = createFont{name='tahoma', height=9}</div>

<div class="cmd">image createImage(string path [,int param])</div> - загрузка картинки. Поддерживаются форматы: <div class="m">png</div>, <div class="m">bmp</div>, <div class="m">jpg</div>, <div class="m">gif</div>, <div class="m">ico</div>.
Дополнительный (необязательный) параметр используется <div class="m">gif</div> - номер кадра, и <div class="m">ico</div> - размер иконки, который нужно загрузить. 
Если параметр не указан, загружается первый кадр/иконка в файле.
В пути к файлу можно использовать как прямую косую черту '/', так и обратную '\\' (требуется удвоенное количество).
<div class="cmd">void drawImage(image, x, y [, w, h])</div> 
<div class="cmd">void drawImage(image, table rect)</div> - рисование картинки. Требуется указать координаты для рисования и если необходимо размер.
Если указан размер, то картинке будет растянута на заданный прямоугольник. Размер можно указать с помощью высоты и ширины, или
указав прямоугольник в виде таблицы. О формате таблицы см. функцию <div class="cmd">render:rect</div>.

<div class="cmd">void select(pen|brush|font)</div> - установка пера, кисти или шрифта, как текущих для рисования.
<div class="cmd">void rect(table rect)</div> - рисование прямоугольника текущем пером.

Возможные варианты определения <div class="m">rect</div> (прямоугольника):
<ul>- { left, top, right, bottom } - через определение границ прямоугольника.
- { left, top, width, height } - через определение левой и верхней границ + ширина и высота.
- { x, y, width, height } - через определение левой верхней точки + ширина и высота (аналог предыдущего варианта).
- { 10, 20, 30, 40 } - через простой набор чисел. В таком случае используется 
вариант left, top, right, bottom соответственно.
</ul>Примеры:<div class="ee">local r = { left=10, right=20, top=10, bottom=20 }
render:solidRect{ x=10, y=20, width=10, height=10 }
render:solidRect{ x=20, y=30, width=10, height=10, color={r=20} }
local r2 = { 10, 20, 40, 50 }
render:rect(r2)
</div>
<div class="cmd">void solidRect(table rect)</div> - рисование закрашенного прямоугольника. Используется текущая кисть. Формат rect см. выше. Можно указать 
цвет сплошной заливки, с помощью параметра <a class="cmd" href="#color">color</a>. Пример смотрите выше.
<div class="cmd">void print(int x, int y, string text)</div> - печать текста по заданным координатам. Используется текущий шрифт и цвет <div class="cmd">textColor</div>.
<div class="cmd">void print(table rect, string text)</div> - печать текста в заданном прямоугольнике по центру. Используется текущий шрифт и цвет <div class="cmd">textColor</div>. 
Текст обрезается, если он не вписывается в заданный прямоугольник.
<div class="cmd">void update()</div> - сообщить окну, что нужно перерисовать содержимое.
<div class="cmd">int fontHeight()</div> - возвращает высоту текущего шрифта в пикселях.
<div class="cmd">int textWidth(string text)</div> - возвращает ширину текста в пикселях (для расчета используется текущий шрифт).
</pre>
<hr>
<a name="image"></a>
<h4>image</h4>
Объект представляет собой изображение-картинку, которое загруженно методом <div class="cmd">createImage</div> (см. <a href="#render" class="cmd">render</a>).<br>
Для объектов доступны следующие методы:
<pre>
<div class="cmd">int width()</div> - ширина изображения в пикселях.
<div class="cmd">int height()</div> - высота изображения в пикселях.
<div class="cmd">image cut(image, table rect)</div> - создание нового изображения, путем вырезания из другого. (см.  <div class="cmd">render:rect</div>).
</pre>
Для рисования предназначен: <div class="cmd">render:drawImage</div>. См. также <a href="#imagecpp" class="cmd">class Image</a>.
<hr>
<a name="props"></a>
<h4>props</h4>
Данный набор функции предназначен для получения текущих настроек клиента. С помощью данных методов настройки изменить нельзя. В С++ есть 
аналогичный набор методов: <a href="#cppprops" class="cmd">luaT_Props</a>.
<pre>
<div class="cmd">uint paletteColor(int index)</div> - цвет из палитры клиента по индексу. Допустимые значения индекса от 0 до 255.
Пример получения цвета текста с индексом 7 (цвет по умолчанию):
<div class="ee">local color = props.paletteColor(7)</div>
<div class="cmd">uint backgroundColor()</div> - цвет фона всех окон клиента.
<div class="cmd">font currentFont()</div> - текущий шрифт в клиенте.
<div class="cmd">string cmdPrefix()</div> - символ-префикс для системной команды. Не используйте в плагинах 'жестко' заданный символ команды (он может поменяться).
<div class="cmd">string cmdSeparator()</div> - символ-разделитель для команд. Не используйте 'жестко' заданный символ сепаратора в плагинах (он может поменяться).
<div class="cmd">string serverHost()</div> - возвращает адрес сервера, к которому подключен клиент или nil, если нет подключения.
<div class="cmd">string serverPort()</div> - возвращает порт сервера или nil, если нет подключения.
<div class="cmd">bool connected()</div> - возвращает признак наличия подключения.
<div class="cmd">bool activated()</div> -  признак, что окно клиента активно и игрок работает с ним.
<div class="cmd">bool isPropertiesOpen()</div> - признак, что открыто окно настроек клиента, см. <a href="#propsblocked" class="cmd">propsblocked</a>.
<div class="cmd">false|int pluginsLogWindow()</div> - возращает номер окна, куда выводится лог плагинов. Если вывод логов отключен, то возвращается false.
</pre>
<hr>
<a name="luaactobj"></a>
<h4>Манипуляции с объектам клиента.</h4>
Данные функции(объекты) предназначены для манипуляции с триггерами, макросами и др. элементами клиента. Данное описание 
корелируется с классом <a href="#cppactobj" class="cmd">luaT_ActiveObjects</a>, так как они предназначены для одно и того же.<br><br>
Доступ из скриптов Lua идет через использование глобальных объектов:
<ul>
<li><div class="m">aliases</div> - макросы</li>
<li><div class="m">actions</div> - триггеры</li>
<li><div class="m">subs</div> - замены</li>
<li><div class="m">antisubs</div> - антизамены</li>
<li><div class="m">highlights</div> - подсветки</li>
<li><div class="m">hotkeys</div> - горячие клавиши</li>
<li><div class="m">gags</div> - фильтры</li>
<li><div class="m">vars</div> - переменные</li>
<li><div class="m">groups</div> - группы</li>
<li><div class="m">timers</div> - таймеры</li>
<li><div class="m">tabs</div> - подстановки</li>
</ul>
<div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, как это принято в языке Lua.
<br><br>Данные объекты полностю идентичны, и это список их функций:
<pre>
<div class="cmd">int  size()</div> - возвращает число элементов.
<div class="cmd">bool select(int index)</div> - выбор элемента для работы.
<div class="cmd">bool set(string type, string value)</div> - задает значение атрибута для текущего элемента.
Возможные варианты атрибута: 'key', 'value', 'group'.
<div class="cmd">string get(string type)</div> - возвращает значения атрибута. Если атрибут неверный, возвращается nul.
<div class="cmd">bool add(string key[ ,string value, string group])</div> - добавляет новый элемент. Если не указана группа, то 
элемент добавляется в первую группу. Если элемент существует, то происходит ошибка и добавление не происходит.
<div class="cmd">bool replace(string key[ ,string value, string group])</div> - заменяет текущий элемент. Если элемент не 
существует, то он добавляется.
<div class="cmd">bool delete()</div> - удаляет текущий элемент.
<div class="cmd">int  getIndex()</div> - возвращает индекс-приоритет текущего элемента.
<div class="cmd">bool setIndex(int index)</div> - установка текущего приоритета у текущего элемента.
</pre>
Пример (добавить макрос есть):
<pre><div class="ee">aliases.add("есть", "съесть хлеб", "default")
</div></pre>
<hr>
<a name="viewdata"></a>
<h4>viewdata</h4>
Объект, который не является глобальным, используется при работе с методами <a href="#before" class="cmd">before</a>, 
<a href="#after" class="cmd">after</a>, <a href="#updateView" class="cmd">updateView</a>, <a href="#triggers" class="cmd">Lua-триггерами</a>. 
Он предназначен для манипуляции со строками, которые плагин получает от клиента 
через эти методы. В C++ есть подобный интерфейс <a href="#cppviewdata" class="cmd">luaT_ViewData</a>.
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, как это принято в языке Lua.
<pre>
<div class="cmd">int  size()</div> - возвращает количество строк в коллекции.
<div class="cmd">bool select(int index)</div> - выбор текущей строки для работы.
<div class="cmd">int  getIndex()</div> - индекс текущей строки.
<div class="cmd">bool isFirst()</div> - возвращает признак, что первая строка - это продолжение последней строки прошлой коллекции.
<div class="cmd">bool isLast()</div> - последняя строка является завершенной, ее продолжения в следующей коллекции не будет.
<div class="cmd">bool isGameCmd()</div> - в строке присутствует игровая команда.
<div class="cmd">bool isSystem()</div> - это строка со служебной информацией  (логи клиента и плагинов, команды клиента).
<div class="cmd">bool isPrompt()</div> - это prompt-строка.
<div class="cmd">bool isDropped()</div> - строка была отброшена в одном из триггеров и не будет отображена в клиенте.
<div class="cmd">string getPrompt()</div> - содежимое prompt-строки (без игровых команд).
<div class="cmd">string getText()</div> - полный текст строки (без учета расцветок отдельных блоков).
<div class="cmd">int  getTextLen()</div> - длина полного текста строки.
<div class="cmd">string getHash()</div> - хэш строки. Используется для быстрого сравнения строк.
<div class="cmd">int  blocks()</div> - количество блоков в текущей строке.
<div class="cmd">uint get(int index, string attr)</div> - получает значение атрибута блока. Возможные варианты атрибута: 
<div class="m">textcolor</div>,<div class="m">bkgcolor</div>,<div class="m">underline</div>,<div class="m">italic</div>,<div class="m">blink</div>,<div class="m">reverse</div>,<div class="m">exttextcolor</div>,<div class="m">extbkgcolor</div>.
<div class="cmd">bool set(int index, string attr, uint value)</div> - задает значение атрибута блока. Возможные варианты атрибута см. в <div class="m">get</div>.
<div class="cmd">string getBlockText(int index)</div> - текст блока по заданному индексу.
<div class="cmd">bool setBlockText(int index, string text)</div> - задает новый текст блоку по индексу.
<div class="cmd">bool copyBlock(int block, int dst_string, int dst_block)</div> - копирует заданный блок текущей строки в другую строку.
<div class="cmd">bool deleteBlock(int index)</div> - удаляет блок.
<div class="cmd">bool deleteAllBlocks()</div> - удаляет все блоки, остается пустая строка.
<div class="cmd">bool createString([bool system, bool gamecmd])</div> - создает новую пустую строку. Строка добавляется между текущей строкой и следующей за ней. 
Необязательные параметры system, gamecmd - задают соответствующие флаги для новой строки.
<div class="cmd">bool deleteString()</div> - удаляет строку.
<div class="cmd">void print(int view)</div> - печатает текущую строку в заданное output-окно с цветом.
<div class="cmd">bool find(pcre regexp [,int from])</div> - ищет в массиве строк <div class="cmd">viewdata</div> строку, которая совпадает с регулярным выражением. 
Если поиск удался, то найденная строка становится текущей. Параметр from - необязательный, можно указать с какой 
строки начинать поиск. См. также <a href="#pcre" class="cmd">pcre</a>.
<div class="cmd">int,int getBlockPos(int symbol)</div> - возвращает номер блока и позицию в блоке для текущей строки по номеру символа во всей строке (полная строка).
Если не может рассчитать, то возвращает nil,nil. Предназначена для работы совместно с функцией <div class="cmd">viewdata.getText</div>.
<div class="cmd">bool setNext(bool next)</div> - используется в механизме деления строк. Устанавливает/снимает флаг, что следующая строка часть текущей.
<div class="cmd">bool setPrev(bool prev)</div> - Предыдущая строка часть текущей (механизм деления строк).
<div class="cmd">bool isNext()</div> - проверка флага, что следующая строка часть текущей (механизм деления строк).
<div class="cmd">bool isPrev()</div> - проверка флага, что предыдущая строка часть текущей (механизм деления строк).<br>
Функции, которые работают только в обработчиках Lua-триггеров.
<div class="cmd">int  parameters()</div> - количество параметров для текущей строки в Lua-триггере.
<div class="cmd">string getParameter(int index)</div> - возращает значение параметра %0,%1 и т.д (по значению index) для текущей строки в 
Lua-триггере. Если вернуть значение невозможно (неправильный индекс или это не Lua-триггер), то результат функции nil.
Под индексом %0 - полная строка на которую сработал триггер (если %0 не используется в триггере).
<div class="cmd">bool isChanged()</div> - флаг-признак, что строка была изменена. Т.к. триггеры на Lua могут изменять строки, то возможно, 
что строка на которую сработал триггер уже изменилась в другом триггере.
<div class="cmd">string getKey()</div> - возвращает регулярное выражение/триггер на которое сработала текущая строка. Если вернуть значение 
невозможно (это не Lua-триггер), то результат функции nil.
Подробнее про Lua-триггеры <a href="#triggers">тут</a>.
</pre>
<hr>
<a name="luamsdp"></a>
<h4>msdp</h4>
Объект предназначен для управления протоколом MSDP из плагина. Все данные по протоколу плагин будет получать через свой метод <a href="#msdp" class="cmd">msdp</a>. 
Сам стандарт протокола можно прочитать тут: <a href="http://tintin.sourceforge.net/msdp/" target="_blank">MSDP</a>.

<pre>
<div class="cmd">void list(string listname)</div> - запрос на получение списка команд/переменных нужной категории из числа поддерживаемых сервером. 
Чтобы получить список поддерживаемых категорий следует вызвать с параметром "LISTS" (см. станадрт протокола).
<div class="cmd">void send(string var|table vars)</div> - запрос на однократное получение текущих значений требуемых переменных. В качестве параметра - 
строка с именем переменной или таблица со списком переменных.
<div class="cmd">void reset(string var|table vars)</div> - запрос на сброс значений требуемых переменных в исходное состояние.
<div class="cmd">void report(string var|table vars)</div> - подписывание на оповещение сервером об изменении значений нужных переменных.
<div class="cmd">void unreport(string var|table vars)</div> - отказ об оповещения сервером об изменении значений переменных.
</pre>
См. также <a href="#cppmsdp" class="cmd">luaT_Msdp</a>.
<hr>
<a name="pcre"></a>
<h4>pcre</h4>
Это библиотека для работы с регулярными выражениями в стиле Perl. Для ее использования нужно знать данный диалект регулярных выражений. 
Она используется для сложного поиска и разбора текстовых строк. С ее помощью можно лекго искать нужные строки текста. 
На стороне С++ есть подобная возможность (см. <a href="#pcrecpp" class="cmd">Pcre в C++</a>). 
Регулярки в Lua создаются с помощью функции  <a href="#createpcre" class="cmd">createPcre</a>. 
<pre>
<div class="cmd">bool find(string text)</div> - обработка строки в регулярном выражении. Возвращает <div class="m">true</div>, если строка подходит к 
регулярному выражению или <div class="m">false</div>, если нет.
<div class="cmd">bool findall(string text)</div> - обработка строки в регулярном выражении. Ищутся все совпадения в строке, а не только первое.
Возвращает <div class="m">true</div>, если есть хоть одно совпадение, <div class="m">false</div>, если нет ни одного.
<div class="cmd">int size()</div> - возвращает количество совпадений в регулярном выражении. Для метода <div class="cmd">find</div> - возвращается 
количество найденных параметров в круглых скобках + 1 (совпадение по всему регулярному выражению).
Для метода <div class="cmd">findall</div> - количество всех найденных совпадений + 1 (для границ всех совпадений).

<div class="m">Пояснение:</div> 
Для каждого совпадения есть два числа - начало сопадения в строке поиска и окончание совпадения. 
Для метода <div class="cmd">find</div> - это границы для подстрок, попадающих в круглые скобки регулярного выражения. 
С индексом 1 - первые круглые скобки, 2 - вторые и т. д. Индекс 0 - границы совпадения всего регулярного выражения.
Для метода <div class="cmd">findall</div> - это границы для подстрок, которые подходят к регулярному выражению.  
С индексом 1 - первое совпадение, и т.д. Индекс 0 - границы всех совпадений (начало первого и окончание последнего совпадений).
<div class="cmd">int first(int index)</div> - возвращает левую границу (индекс символа в исходной строке), или -1 для неправильного индекса.
<div class="cmd">int last(int index)</div> - возвращает правую границу (индекс символа в исходной строке + 1), или -1.
<div class="cmd">string get(int index)</div> - возвращает подстроку по индексу (от левой границы до правой) или пустую строку, 
для неправильного индекса.
<div class="cmd">string regexp()</div> - возвращает регулярное выражение.
</pre>
<hr>
<a name="strings"></a>
<h2>Cтроки, ньюансы работы в Lua</h2>
В клиенте используется кодировка UTF8 для файлов на языке Lua, соответственно вся работа со строками в Lua идет в этой же кодировке. В текущей реализации Lua 5.2, которая 
используется в клиенте, нет нативной поддержки UTF8. Соответственно есть определенные ньюансы работы.<br><br>
- В клиенте не используется официальная библиотека <div class="m">string</div> для работы со строками, т.к. она не расчитана на работу с UTF8.<br>
- Операторы <div class="m">==</div>, <div class="m">~=</div>, <div class="m">&lt;</div>, <div class="m">&gt;</div> для сравнения строк можно использовать, 
так как сравнение идет побайтно, а UTF8 обладает свойством, что для нее прекрасно работают операторы сравнения обычных строк.<br>
- Оператор <div class="m">#</div> - длина строки будет работать неправильно, так как он будет возвращать длину строки в байтах, а не в символах.<br><br>
Примечание: К сожалению Lua не позволяет переопределить стандартные операторы для строки, поэтому для оператора <div class="m">#</div> не получилось сделать его 
правильную реализацию. Возможно решение этой проблемы будет найдено позднее.<br><br>

<h4>string</h4>
Для работы со строками, были написаны свои функции:<br>
<div class="m">Внимание!</div> Все индексы символов строки начинаются с 1, а не с 0, так как это принято в языке Lua.<br>
<pre>
<div class="cmd">int len()</div> - длина строки в символах. Данную функцию нужно использовать вместо оператора <div class="m">#</div>.
Пример:
<div class="ee">local s = "Мад отличная игра"
local l = s:len() -- l = 17
</div>
<div class="cmd">string substr(int len)</div> - возвращает подстроку (часть исходной строки) длиной в <div class="m">len</div> первых символов.
<div class="cmd">string substr(int from, int len)</div> - возвращает подстроку(часть исходной строки),
начиная с символа <div class="m">from</div> и длиной <div class="m">len</div> символов. <div class="m">from</div> начинается с 1 (первый символ).
Пример:
<div class="ee">local s = "Мад отличная игра"
local s1 = s:substr(3) -- s1 = "Мад"
local s2 = s:substr(5, 8) -- s2 = "отличная"
</div>
<div class="cmd">int strstr(string what [,int from])</div> - ищет подстроку в строке. Можно указать с какого символа нужно искать.
<div class="cmd">table strall(string what)</div> - ищет все вхождения подстроки в строке. Возвращает таблицу индексов с которых начинается 
заданная подстрока (nil - ничего не найдено).
<div class="cmd">string lower()</div> - возвращает новую строку - это текущая строка в нижнем регистре.
<div class="cmd">string upper()</div> - возвращает новую строку - это текущая строка в верхнем регистре.
<div class="cmd">string lfup()</div> - возвращает новую строку - это текущая строка в нижнем регистре, но первая буква в верхнем(заглавная),
предназначена для нормализации имен предметов и других объектов.
Пример:
<div class="ee">local s = "Мад отличНая Игра"
local s1 = s:lower()
local s2 = s:lfup()
-- s1 = "мад отличная игра"
-- s2 = "Мад отличная игра"
</div>
<div class="cmd">table tokenize(string delimeters)</div> - возвращает таблицу подстрок. Создается из основной строки, разделенная на символы из строки delimeters.
</pre>
<hr>
<a name="triggers"></a>
<h2>Триггеры на Lua</h2>
В клиенте есть возможность создавать игровые триггеры на Lua. Если классические триггеры (actions, subs и др.) при срабатывании на заданной строке выполняли набор нужных игровых 
команд, то Lua-триггеры запускают на выполнение Lua-функцию. Это дает безграничные возможности по автоматизации игрового процесса, т.к. тут подключается вся мощь целого языка 
программирования.<br><br>
Триггер создается функцией <a href="#createTrigger" class="cmd">createTrigger</a>. Триггер создается активным (enabled).<br>
Пример:
<div class="ee">
<pre>
local function in_trigger1(v)
-- v - это объект viewdata со строками мада
...
end

local function in_trigger2(v)
...
end

-- вызывается при загрузке плагина
local t1,t2
function plugin.init()
  t1 = createTrigger("%1 приш%2 с %3", in_trigger1 )
  t2 = createTrigger( {"%1 оглушил %2.", "%1 упал%2 на пол."}, in_trigger2 )
  createTrigger({"", "%1 улетел на %2"}, in_trigger2 )

  -- можно использовать регулярки, нужно вначале нужно писать $, как признак регулярки
  -- сам символ $ в регулярном выражении не учавствует
  createTrigger("$(.*) прилете(?:ла|л|ли) с (.*)", in_trigger1)
end

local function some_function()
...
  t1:disable()
...
  if x then t1:enable() end
...
  if t2:isEnabled() then ... end
end
</pre>
</div><br>
Результатом функции <div class="cmd">createTrigger</div> - является объект <a href="#trigger" class="cmd">trigger</a>. Через который можно управлять триггером (включать/отключать).
Клиент позволяет создавать однострочные и многострочные триггеры. Многострочные триггеры задаются через таблицу строк.<br><br>
При создании триггера необходимо указать функцию, которая будет вызвана при срабатывании триггера. Для нескольких триггеров можно использовать одну и ту же функцию.<br><br>
При срабатывании триггера в функцию-обработчик будет передан объект <a href="#viewdata" class="cmd">viewdata</a> с набором всех строк мада, на которых произошло срабатывание. 
Через данный объект можно изменять строки, менять им цвет, полностью отбрасывать. Также можно получить значения переменных %1 и т.д. для каждой строки триггера.<br>
Для работы с параметрами Lua-триггера есть следующие функции:
<ul>
<li><div class="cmd">viewdata:parameters()</div> - количество параметров %x. Возвращает максимальное значение %x в строке триггера.</li>
<li><div class="cmd">viewdata:getParameter(int index)</div> - значение параметра %x. index - от 0 до последнего %x в строке триггера. В параметр %0 попадает вся строка, на 
которую сработал триггер, при условии, что %0 не используется в триггере.</li>
<li><div class="cmd">viewdata:isChanged()</div> - флаг, что строка изменилась. Строка могла измениться в другом триггере, и если текущий триггер тоже изменяет строку, то нужно 
учитывать тот факт, что строка может быть уже другой.</li>
<li><div class="cmd">viewdata:select(int index)</div> - нужно предварительно выбрать нужную строку, с которой планируется работать.
</ul>
В многострочных триггерах допускается задавать пустые строчки (но не все). В таком случае - это означает любая строка на данной позиции.<br><br>
Также можно использовать полноценные регулярные выражения PCRE. Клиент различает регулярное выражение и обычную строку триггера по наличию вначале регулярного 
выражения символа '$'. Символ $ в регулярном выражении не учавствует(на данной позиции он не имеет смысла).<br><br>
При написании регулярок в переменные %x будут попадать значения круглых скобок по правилам PCRE. Для тестирования регулярок есть плагин калькулятора PCRE.<br><br>
Все это дает возможость создавать триггеры практически любой сложности. Триггеры автоматически выгружаются вместе с плагином.
<a name="trigger"></a>
<h4>trigger</h4>
Объект, который создается функцией <a href="#createTrigger" class="cmd">createTrigger</a> и позволяет управлять работой триггера.
<pre>
<div class="cmd">void disable()</div> - выключить триггер. Триггер перестанет срабатывать.
<div class="cmd">void enable()</div> - включить триггер. Триггер начнет срабатывать на строки, заданные при создании триггера.
<div class="cmd">bool isEnabled()</div> - текущее состояние триггера.
</pre>
<hr>
<a name="decoda"></a>
<h2>Decoda</h2>
<div class="m">Decoda</div> - является средой разработки для языка Lua. Она очень хорошо интегрируется и работает вместе с мад-клиентом. Она позволяет писать и отлаживать 
Lua-скрипты как отдельно, так и параллельно с Visual Studio. Decoda входит в SDK.<br><br>
Для работы с Decoda ее нужно настроить, для этого в окне <div class="m">Debug\Project Debug Settings</div> нужно выставить правильно настройки:
<ul>
<li><div class="m">Command</div> - это полный путь к exe мад клиента.</li> 
<li><div class="m">Command Arguments</div> - пустое поле.</li> 
<li><div class="m">Working Diectory</div> - полный путь к папке, где находится мад-клиент, должен совпадать с путем в поле Command, автоматом подставляется, при 
изменении поля Command.</li> 
<li><div class="m">Symbols Directory</div> - пустое поле.</li>
</ul>
После этого можно добавлять в Decoda lua-файлы с плагинами и отлаживать их. Decoda будет сама запускать для этого мад-клиент и отслеживать загружаемые lua-файлы.<br><br>
Порядок работы в Decoda следующий:<br>

1. Настроить Decoda для работы с мад-клиентом, как описано выше.<br>
2. Создать новый Lua-файл <div class="m">File\Add New File</div> или загрузить существующий из папки клиента <div class="m">File\Add Existing File</div>, который нужно написать и отладить.<br>
3. Можно сохранить настройки проекта и список файлов <div class="m">File\Save Project</div>, чтобы не повторять пункты 1 и 2.<br>
4. Можно запустить отладку <div class="m">Debug\Start Debugging</div>. После этого запуститься клиент, клиент загрузить Lua-файлы, Decoda отследить это и
в окне проекта появится список загруженных файлов в клиент.<br>
5. В окне Decoda появится папка <div class="m">Debug Temporary Files</div>, куда добаяться файлы, которые загрузил клиент, но не были добавлены в проект в п.2<br>
6. Можно ставить точки остановки <div class="m">Debug\Toggle Breakpoint</div> и когда клиент дойдет до данной строки - отладчик прервет управление и можно будет 
отлаживаться, выполнять код построчно, смотреть значения переменных и т.д.<br>
7. При остановке отладки <div class="m">Debug\Stop Debugging</div> клиент будет закрываться.<br>
<div class="cmd">ВАЖНО!!!</div> В настройках клиента отлаживаемый плагин должен загружатся, иначе точки остановки срабатывать не будут!

<br><br>PS. Комбинации клавиш в Decoda подобны комбинации в Visual Studio, поэтому если вы работали в студии, то будет удобно.<br>
Данная версия Decoda была заточена под клиент для удобной работы. Сделана поддержка кодировки utf8.<br>
<hr>
<br><br><br>
</body></html>
